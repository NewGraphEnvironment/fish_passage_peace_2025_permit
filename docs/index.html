<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","knit":"pagedown::chrome_print","links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/lucy-schick/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/lucy-schick/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://www.newgraphenvironment.com/fish_passage_peace_2025_permit/\" class=\"uri\">https://www.newgraphenvironment.com/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-16</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://github.com/lucy-schick/fish_passage_peace_2025_permit">at this link</a>. A summary of sites to be potentially assessed (including historic fish presence information available in FISS) is included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a>. Details of fish species known within each watershed is presented in Table <a href="#tab:tab-fish">4</a>, and an overview map displaying potential sample locations is included in Figure <a href="#fig:map">1</a>. A kml file of the sites is included as an attachment to the application and can also be downloaded <a href="https:/github.com/lucy-schick/fish_passage_peace_2025_permit/blob/main/docs/sites_peace_2025_20250716_kml.zip">at this link</a>. There is an extensive amount of information contained in the kml file (accessed by clicking on sites) including brief summaries of background reporting data (when available).</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program and the Provincial Fish Passage Technical Working Group. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are provided below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br>
<br>
<br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dipnetting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. Our study plan is (when time allows and PIT tagging is expected to increase our state of knowledge about the subject system) to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and insert biomark APT12 PIT tags into the body cavity of select fish captured over 60mm in fork length. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<!-- ![signature](/Users/airvine/Library/CloudStorage/OneDrive-Personal/Admin/Al_Sig.jpg){width=50%} -->
<p>Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125825
</td>
<td style="text-align:left;">
Purvis Creek
</td>
<td style="text-align:left;">
237-673200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355055
</td>
<td style="text-align:right;">
6122848
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200337
</td>
<td style="text-align:left;">
Moosmoos Creek
</td>
<td style="text-align:left;">
237-528900-48700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
406967
</td>
<td style="text-align:right;">
6138657
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201576
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-331000-04000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
429809
</td>
<td style="text-align:right;">
6124738
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400370
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-913400-47700-11700-2890-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
453321
</td>
<td style="text-align:right;">
6157621
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400506
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-901300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456059
</td>
<td style="text-align:right;">
6188410
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701130
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-846900-11400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522727
</td>
<td style="text-align:right;">
6199674
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701150
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-860500-56200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
482825
</td>
<td style="text-align:right;">
6240727
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701333
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-846900-18000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522811
</td>
<td style="text-align:right;">
6196513
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701346
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-846900-21000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
523799
</td>
<td style="text-align:right;">
6194962
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701712
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-871000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488844
</td>
<td style="text-align:right;">
6198242
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701773
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-828500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
540327
</td>
<td style="text-align:right;">
6221480
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:left;">
230-906800-65600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
198692
</td>
<td style="text-align:left;">
Tributary To Kerry Lake
</td>
<td style="text-align:left;">
230-906800-97600-22400-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511734
</td>
<td style="text-align:right;">
6059315
</td>
<td style="text-align:left;">
CRKD
</td>
</tr>
<tr>
<td style="text-align:left;">
23502802
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-815600-04500-63200-0210-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
530426
</td>
<td style="text-align:right;">
6205816
</td>
<td style="text-align:left;">
UPCE
</td>
</tr>
<tr>
<td style="text-align:left;">
23502870
</td>
<td style="text-align:left;">
Track Creek
</td>
<td style="text-align:left;">
230-815600-09900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
545962
</td>
<td style="text-align:right;">
6203536
</td>
<td style="text-align:left;">
UPCE
</td>
</tr>
<tr>
<td style="text-align:left;">
23502871
</td>
<td style="text-align:left;">
Gaylard Creek
</td>
<td style="text-align:left;">
230-815600-04500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
531258
</td>
<td style="text-align:right;">
6206271
</td>
<td style="text-align:left;">
UPCE
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62622
</td>
<td style="text-align:left;">
Unnamed Tributary To Tributary Of Chuchi Lake
</td>
<td style="text-align:left;">
237-447200-60000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
421633
</td>
<td style="text-align:right;">
6103622
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
7819
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
230-870800-11500-24500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488605
</td>
<td style="text-align:right;">
6187223
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
7827
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
230-870800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
506054
</td>
<td style="text-align:right;">
6164113
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125825
</td>
<td style="text-align:left;">
Purvis Creek
</td>
<td style="text-align:left;">
BB;BT;CAS;CSU;LKC;LSU;LT;LW;MW;PW;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200337
</td>
<td style="text-align:left;">
Moosmoos Creek
</td>
<td style="text-align:left;">
BB;BT;CCG;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201576
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400370
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400506
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701130
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;LSU;LT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701150
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701333
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701346
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701712
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701773
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198692
</td>
<td style="text-align:left;">
Tributary To Kerry Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
23502802
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
23502870
</td>
<td style="text-align:left;">
Track Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
23502871
</td>
<td style="text-align:left;">
Gaylard Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62622
</td>
<td style="text-align:left;">
Unnamed Tributary To Tributary Of Chuchi Lake
</td>
<td style="text-align:left;">
CSU;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7819
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7827
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
BT;DV;LSU;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
<th style="text-align:left;">
Peace Arm
</th>
<th style="text-align:left;">
Upper Peace
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
