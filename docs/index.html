<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABN8AAAGRCAYAAABVBRUGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAV3pJREFUeNrs3T+UE0m+KOiEqXOYtabaG2+Et14X3l0LlXfXovDuWl1lrgV4uxZgPguwdteqwnr7LApvn4Ww9j0LjXc91N5dqzXe1DnQvRkQ6k6EpMxU/k993zk61U2VpMiIyPjzy8iMJAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgKM7d07S14sepec8vJQMAAAAAIMWA2+/pK/f+hCAi4G33+LrXAkBAAAAMEhrgbfOA159Sw8AAAAA7GVLoGv1mnaQnuMd6TlXYgAAzbstCwAAqguBt/THu/R1vOVP3oRgWMvJerMjPZcCcAAAzRN8AwCoqEDgLYm/e9Nimp6lP6Y5fyYABwDQsD/JAgCA/RUMvK1Mbh8d/ePXz5//Wwtp+s8F//wsTdPPaZrmShMAoH63ZAEAwH5KBt5Wlunr7qebm2WD6fqQ/jgp+baLNE1XShUAoF5uOwUA2MOegbck/v2LBtN1npQPvAVuQQUAaICVbwAAJVUIvGWF1W+LmtMV0vOxYrqsgAMAqJGVbwAAJdQUeAueNpC8xzWkywo4AIAaWfkGAFBQjYG3lVpXv6Xp+6XGtFkBBwBQAyvfAAAKaCDwFjytMX3nNafNCjgAgBpY+QYAkKOhwFtQ286ne+5wWoQVcAAAFVj5BgCwQ4OBtyR+5lkNaZwkzQTeAivgAAAqEHwDANii4cDbyoMaPuOs4awQgAMA2JPbTgEANmgp8PbFp5ubWxXT2tQtp+vcggoAUJKVbwAAa9oMvMXvO6vw3pDGk5ayxgo4AICSBN8AADLaDrxF9yu8d9pyFgnAAQCUIPgGABB1FHgLqqxcu99BVgnAAQAUJPgGAJB0GngLphXee9JRlgnAAQAUIPgGABy8jgNvqzRM9nzrSYdZJwAHAJBD8A0AOGh9CLxFkz3f13W6BeAAAHYQfAMADlaPAm/BZI/0T3uSlQJwAABbCL4BAAepZ4G3YDLwLBWAAwDYQPANADg4PQy8jYUAHADAGsE3AOCgjCzwdtLDNAnAAQBkCL4BAAdjhCve+nocAnAAAJHgGwBwEEZ6q+myx2kTgAMASATfAIADMOJnvM17nj4BOADg4Am+AQCjZnOFzgnAAQAHTfANABitgQXeFiMuCgE4AOBgCb4BAKM0wBVviz3eMx9QkQjAAQAHSfANABidgd5quij7hk83N8uBFY0AHABwcATfAIBRGeoz3j7d3Cz2fOtsYEUkAAcAHBTBNwBgNAa8ucKswnvnAywqATgA4GAIvgEAozDwXU2rBND+PtAiE4ADAA6C4BsAMHgDD7wF7yu8dzbgohOAAwBG75YsAACGbASBt/C8t1sV8+Bj+mMy4GK8SPPgSm0GAMbIyjcAYLDGEHhLXffkM7pkBRwAMFqCbwDAII0k8Ba8reEzXo+gSAXgAIBRctspADA4Iwq8LdPX3U83N8sa8uRD+uNkBMXrFlQAYFSsfAMABmVEgbfguo7AW/RqJEVsBRwAMCpWvgEAgzGywFsQVr0tasqbkCcfR5Q3VsABAKPwJ1kAAAzBCANvV59ubmp7Vtuvnz//8/bR0f+Q/ud0JPlzlh7Pz+lxzdV+AGDIrHwDAHpvhIG3oLZVb5l8Gtvqt8AKOABg0Kx8AwB6baSBt1pXva2McPVbYAUcADBoVr4BAL010sBbbTuc7si3sPptMrLqYAUcADBIdjsFAHpppIG34HmTgbfoYoRVwi6oAMAgue0UAOidEQfeZp9ubv7Xpr/k18+fF7ePjkLe/cvI8s8tqADA4Ai+AQC9MuLAW1jt9j+F57K18WW3j47+e/rjX9PXX0eWjwJwAMCgCL4BAL0Rd+v8kIwv8Bb8z59ubv69rS+Lmy+EANy/pa8/jywvBeAAgMHwzDcAoBdi4G2MK96CsFnArO0vTb8zBKcuRlplPAMOABgEK98AgF64fXT0n9Mf0xEe2stPNzf/qasv//Xz538Pq8TS/zwbYd5aAQcA9J7gGwDQuaM7dx6nPx6P8NCu2thgIU8ITgnAAQB0Q/ANAOhU3GDhzQgPLQTeenPLpwAcAEA3BN8AgM7E57yFwNvYduQMz3h73rdECcABALRP8A0A6Mzto6P/Lfm6G+eYhMDbVV8TJwAHANAuwTcAoDVhpduvnz//M/73JBnf7aa9DrytCMABALTntiwAANoQN1XIuhzZIQ4i8LYS03ox0up2mda3c2cdANAHt2QBANC0ozt3nqU/Xn66uVnG/5+mP96N5PDCMZ2mxzYfaNmcJ+MLhK4MKiAKAIyT204BgEYd3bnzIv3xXz7d3CxW/3b76GgsmywMOvAWuAUVAKBZbjsFABpzdOdOWFH1PhucSv8tBHlORnB4gw+8rbgFFQCgOVa+AQCNiIG3nz/d3Pyf2X+/fXT0f6Q/JgM/vNEE3lasgAMAaIZnvgEAtYuBt5NPNzf31v59mgz/WW8hgHO6en7dCMvuPPEMOACA+sZXsgAAqHVw8TXwdp6+7m349U8DP7xRB96CEJxKyzD85xgDcOEW1EQADgBok2e+AQC1yQTeXq7fkpn+7jgZ9i2Now+8rXgGHABAfTzzDQCoRSbwFoJTD3/9/Pmf2d/fPjr6t/THvw308A4m8LbiGXAAAPWw8g0AqCwTeAtebQlSPRjo4V2FZ9cdUuBtxQo4AIDqbLgAAFSyFngLAaq764GqeMvpLwM8vBB4u1DGNmEAANiXlW8AwN7WAm/B9ZYVYtMBHp7AW2QFHADA/gTfAIC9bAi8Bc+3/Pn9gR2ewNsaATgAgP0IvgEApW0JvM0/3dwstrxlOqDDuxB420wADgCgPME3AKCULYG34PWOt50M5PA8/yuHABwAQDmCbwBAYTsCb8Fsy3umAzk8gbeCBOAAAIoTfAMACskJvC0/3dzMt/xuMoDDE3grSQAOAKAYwTcAIFdO4C2Y7fjdpMeHFnZmvSfwth8BOACAfIJvAMBOBQJvwd93/O7Hnh5aCLyd7lixRwECcAAAuwm+AQBbFQy8BbsCWMc9PDSBtxoJwAEAbCf4BgBsVCLwFiwHdGgCbw0QgAMA2EzwDQD4TsnAWwi8zAZyaCHgdlfgrRkCcAAA3xN8AwC+UTbwNiAh4BZWvC2VcnME4AAAviX4BgD8TuCNOgjAAQD8QfANAPhC4I06CcABAHwl+AYAjDnwdvXp5uaewFs3BOAAAATfAODgjTzwdqGEuyUABwAcOsE3ADhgLQXeuthZVOCtRwTgAIBDJvgGAAeqzsBb+lknO379j5YPTeCthwTgAIBDJfgGAAeogRVvxzt+N2vx0C4E3vpLAA4AOESCbwBwYBq61XTXyrdFS4d2EYM79JgAHABwaATfAOCANPiMtx+3/eLTzc0iaT4AJ/A2IAJwAMAhEXwDgAPR8OYKJzm/nzV4aAJvAyQABwAcCsE3ADgALexqepJ+x67nvr1v4DuX6etU4G24BOAAgEMg+AYAI9dC4G3lbMfvrmv+rlXgbaaEh00ADgAYuz/JAgAYrxYDb8Hy18+f3276Rfrv/7x9dDRJ8m9PLfQ9ydfA21wJj0NaP+Zp/fg52R3AHaqzcGzhGJU0ABwmK98AYKRaDrwFeYGT1zV8h8DbSFkBBwCMlZVvADBCHQTegj/vWuGT/vsi/X0I0P11z88PnxsCb/+uhMfJCjgAYIwE3wBgZDoKvK0c//r589YVbrePjm6S/QIrq8DbfyjhcROAAwDG5pYsAIDx6DjwtnL3083NYkca36U/piU+bxV4Wyrhg6rLoR5fjvTwLuzSCwCHw8o3ABiJngTeguNtGy8EcVVT0XQKvB0oK+AAgLEQfAOAEehR4C04uX109PrXz583Bszis9+O0//8l5zPuUpf/4vA2+ESgAMAxkDwDQAGrmeBt5W81W//Pf3xb+HvtvzJ1aebm4v0M/6phA+bABwAMHSCbwAwYD0NvAVh9dv7sMpt0y9DUC38PvkagPvz2q+/BN6ULpn6IgAHAAyW4BsADFSPA28rJ79+/vx/bftl+rv/uH109P8l3wZUBN7YVl8E4ACAQRJ8A4ABGkDgLfjr7aOjf/z6+fN/2/YHawGVJ59ubv53pUvB+jI2AnAAMFK3ZAEADMtAAm8rYbOEsFvpPOeYJunfLJQuBc+BUP8vR3p4F+m5cKWUAWA8rHwDgAEZWOAtCM9z+5fbR0f/ZdfmCdt2RoUt9cUKOABgMATfAGAgBhh4W/lreO3a/RTKEoADAIZC8A0ABmDAgbeVk7znv0FZAnAAwBAIvgFAz40g8Lbyr4IJ1E0ADgDoOxsuAECPjSjwlnUvbwMG2ONcCeeJTRgAgN4RfAOAnjq6c2ea/ng3wkMrtAMq7HHOnCfjDcDdtSMwAAzTbVkAAP2UTrRn6Y+LER7acfp6d3TnzolSpuZz5mqk58yFwBsADJdnvgFAj434eVZ/Tl//lh7bf02P8T+UNDWfMyHA+y8jOSS3nALAwLntFAAGYMS307kFlabOmTfJ8IPWAm8AMAKCbwAwEAJwUOp8CavfPiZfb3MeIoE3ABgJz3wDgIEY8fOsPAOOJs6X5YDPF4E3ABgRz3wDgAHxDDgOXVjRltaT/zd93YTzIed8+ff070JQ938c0CEKvAHAyLjtFAAGyC2oHGi9/7JKMn2tVkmexl2Bd71nkv74kAzj9lOBNwAYIbedAsAAuQWVQ7Mh8Ba8yasr6bmySH+8GsAhCrwBwEhZ+QYAA2YFHAdSzzcF3lbmsa4sc97f580XBN4AYMSsfAOAAbMCjrHLCbwl8d8vc86TEJi76ukhCrwBwMhZ+QYAI2AFHCOt13mBt6yHaT253vFZk+Tr6rc+EXgDgANg5RsAjIAVcIxNycBbcBnfs+0cWaQ/rnt0iAJvAHAgBN8AYCQE4BiLPQJvq3ryIudvXvfkEAXeAOCAuO0UAEbGLagMvP7uE3jLurerjqSf/0vS7cYLAm8AcGCsfAOAkbECjqGqIfAW5K1+6/LWU4E3ADhAgm8AMEICcAxNTYG3YJpTP952dIgCbwBwoATfAGCkBOAYiliWdQTeVh7t+N2sg0MUeAOAA+aZbwAwcp4BR8/r5yrwVvdz2H5I68Zyy3eG75u2dIgCbwBw4Kx8A4CRswKOvmow8Bac7fjd+5YOUeANABB8A4BDIABH3zQceAse7PhdG6slBd4AgC/cdgoAB8QtqPSkHjYdeFvZeOtp+v2T9MfHBr9X4A0A+J2VbwBwQKyAo2stBt6C6ZbzYNHgdwq8AQDfEHwDgAMjAEdXWg68Bfd3/G7WwPcJvAEA3xF8A4ADJABH2zoIvAVt1gOBNwBgI8E3ADhQAnC0paPAW7CrDtS546nAGwCwleAbABwwATia1mHg7Us9SL+/6e8VeAMAdhJ8A4ADJwBHUzoOvK00Wf4CbwBALsE3AEAAjtr1JPDWJIE3AKAQwTcA4AsBOOqS5vV5IvAGAPCF4BsA8DsBOKqKgbfLpD+Bt2nNnyfwBgCUIvgGAHxDAI59ZQJvYyXwBgCUJvgGAHxHAI6yehx4W9b0OQJvAMBeBN8AgI0E4Ciq5yve5lv+/S8lPkPgDQDYm+AbALCVABx5BnyradGyF3gDACoRfAMAdhKAY5uBP+OtyIYQAm8AQGW3ZAEAUMSIH6Yfngl2+unmZq6Ux1cf0nK9tSX9v+W8VeANAKiFlW8AQCFWwLEyoEDsckv6pznvE3gDAGoj+AYAFCYAx8BWQG5bzbirnAXeAIBaCb4BAKUIwB2uAd56/H7Lv9/f8u8CbwBA7QTfAIDSBOAOz0Cf+TffcByhjM82/K3AGwDQCME3AGAvAnCHI82LEHQb4mYbsw3/JvAGALRK8A0A2JsA3PjFwNv5AJM+T+vnpg0XHqz9v8AbANAowTcAoBIBuPEacOAteL3heCbJtyvfBN4AgMYJvgEAlQnAjc/AA2/B9YZ/e5r5b4E3AKAVt2QBAFCXgT6Uv4hw++Lpp5ub+YGU49ADb7O0rE7XjmmS/vgY/1fgDQBojZVvAEBtrIAbvhEE3oLXG/5ttepN4A0AaJWVbwBA7ayAG2y5jSHwtkjL5+7acU3TH+8SgTcAoANWvgEAtbMCbnhGEngLXq8dVyizcGwCbwBAJ6x8AwAaYwXcYMppLIG3UC5303JZrh3be4E3AKArVr4BAI2xAq7/RhR4C56vBd7CcQm8AQCdsvINAGicFXC9LZcxBd6+edZbemxn6Y9jgTcAoGtWvgEAjbMCrl/Cc9BGFnhLNtSvpcAbANAHVr4BAK2xAq4XZfAlYJi+xrRpxHWa9w+dYQBAHwm+AQCtEoDrNO/HGHj7bpMFAIA+cdspANAqt6B2Y6SBt+ChwBsA0GeCbwBA6wTg2jXiwFvY3XTmjAIA+sxtpwBAZ9yC2koejzXw5jlvAMAgWPkGAHTGCrhmjTjwNh9pvQEARkjwDQDo1AEE4CYdpuFFMr7A2yL5uqrQc94AgEEQfAMAOjfyANybuAKtVel3hsDb+cjyMwTcbLAAAAzKn2QBANAHv37+PL99dPRz+p9nIzu0v4ZXenxv2/rCozt3Qh6+HFk+9uY5egAAZQi+AQC9MeIA3El6XH9Pj+/fm/6izHPe/jyi/BN4AwAGy22nAECvjPgW1MuWbj8Nu8cejyjfBN4AgEETfAMAemekAbgQEHvR5BfE203HtGpQ4A0AGDy3nQIAvTTSW1DD7afv02Nb1P3BcVXdm2Q8q94E3gCAUbDyDQDorZGugHva0Oc+Tl+TkeSRwBsAMBq3ZAEA0HdHd+6cJ1+fZTYWIbA0qzF/wmq3j8k4Vr0JvAEAo2LlGwDQeyNcAVf36rew6k3gDQCgh6x8AwAGY2Qr4O5+urlZ1JQvYdXbZOD5IfAGAIySlW8AwGCMbAXcozo+JO5wOhl4Xgi8AQCjJfgGAAzKiAJwde3i+tPA80HgDQAYNbedAgCDNJJbUCttvBA3WvhlwMcv8AYAjJ6VbwDAII1kBdyDiu8/G/jxC7wBAKMn+AYADNYIAnDTiu+/P+BjvxB4AwAOgdtOAYDBG/gtqD98urlZ7nncQ93l9CIGTgEARs/KNwBg8Aa+Am66z5uO7tyZJAJvAAC9J/gGAIzCgANwJ3u+bzLAYxV4AwAOjuAbADAaAw3A/bjn+6YDO06BNwDgIAm+AQCjMsAA3PGe7/vbgI5R4A0AOFiCbwDA6AwsADf2204F3gCAgyb4BgCM0oACcMcjLgaBNwDg4Am+AQCjNfBdUPOc9Dx9Am8AAIngGwAwciMOwPV5xZzAGwBAJPgGAIzeyFfA9Y3AGwBAhuAbAHAQBOBaIfAGALBG8A0AOBgCcI0SeAMA2EDwDQA4KCMKwM16lBaBNwCALQTfAICD07MA3HLg2SnwBgCwg+AbAHCQehSAm+/5vkUP0v5S4A0AYDfBNwDgYPUkALfY830/d5zuqzT/nqhFAAC7Cb4BAAetBwG4fYNo8w7THAJvNq4AAChA8A0AOHgdB+Bme76vq+CbwBsAQAm3ZAEAwFdHd+6cpz8u2/zOTzc3tyqk95f0x3GLyRV4AwAoyco3AICogxVwVVevzVpMq8AbAMAeBN8AADJaDsC97fj9RQm8AQDsSfANAGBNiwG464rvn7WQRoE3AIAKBN8AADZoIQC3SL9jXjGNi6TZAJzAGwBARYJvAABbNByAe1XT57xuKH0CbwAANbDbKQBAjoZ2Qf3h083Nsoa0hd1OPyb17noq8AYAUBMr3wAAcjSwAu6qjsBbTFv4nKua0ybwBgBQEyvfAAAKqnEF3N34vLa60jVJvq5+q0rgDQCgZn+SBQAAxfz6+fP89tHRz+l/nlX4mBDgel1zupZpusJtp/9SMV0CbwAANbPyDQCgpAor4MItovfqXPWWSVOVZ78JvAEANMTKNwCAkiqsgPtPn25urhtK0z/TNN2k//mvJd8q8AYA0CAr3wAA9lRyBdz8083NvRbS9CH9cVI0TenrtK7NHwAA+J7dTgEA9lRyF9S2VpcV/R6BNwCAFrjtFACggoK3oD5p6nbTDen5jzQ9/0h2334q8AYAAADAcIRbUNPXbxtelx2l53JLej7EzRkAAAAAYDg2BOA6C3SF743fL/AGAAAAwDhkAnCdB7rWAnACbwAAAAAM39GdO2d9CXSl6ThJX28E3gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgHrckgUAAMDK0Z075+mPB+nrOPPPbz/d3LyUOwBQnuAbAAAQgm4h2PYmfU23/Mk8fZ1+urlZyi0AKO62LAAAAFKXyfbAW3CSvt7JJgAo50+yAAAADtvRnTshsFbkttK/3j46+vnXz5/ncg0AirHyDQAAOCvxtw9kFwBDEx6vkL4u09eH9PUxfb1JX2etfLfsBwAASjiWBQAMSXyuaXh0wknmnyfp6yz93cWnm5urRr9fEQBA7wcLYZDwournpIOKU7kJAMABepx8G3jLepGOt6+b3FBI8A0A+i9cqZvKBqBBixJ/63lvAAzN/ZyxdgjMzZr6cs98AwAArtNX0Sv+r2QXABQn+AYAAAcu3mrzpMCfPk//diHHAKA4wTcAACCJD5u+SDavgPsSnEv/5pmcAoByPPMNAAD4IgTgwkOn0/88S77uAhcs0lejD6IGgDETfAMAAH4Xg2xXcgIA6uG2UwAAAABoiOAbAAAAADRE8A0AAAAAGiL4BgAAAAANEXwDAAAAgIYIvgEAAABAQwTfAAAAAKAhgm8AAAAA0JAjWQAA0MKg686d4/THSXwdb/mzZfqap6/Fp5ubxUjzYZrJg7+lr8na8f89/vcqH+ZqT6m8XR5ynqV5sDrHJhvqVzinfo4/513lU5rGSUzXrrYgmB1SeWbayGn8p23lt8qbMbeTk8yxn2TaxKSL445ty8o0lsUqDeFcWo64DIr02WPNg/Vxy64+e9TnZB1uyQIAGMSE+l3Vz0kHRPr99getZ+nrfpysTEp+xDIOZt+mr+uuBvbpcYRjeJFJfxhYP0/Tc1ViAhM+46fMJLKX+RDT+jR9ne9zrB3WtWfpj0eZCWJI90Wa7lmFNudFprzC571KP+9lg+n/aa2OFf6+WEcfxHp2XOKrw/e8Tr/nWQuT+GxbcLzHx4SyfB/PgXmP6t7jWPcm+9S9GCz9KebLvu3DdSZvlh3nx3StLr8tUo/X6shZiXZxddyLGo9hn76rF/1VTcf9YM/zdLHKg/T4rzs8jk199pOiaarpnOxlXUiP7V3yR3B/k9N9+80ibg3gBMgW+KgiqWtXNJJMRcgW+Cij6PS+bmav8Kz+e1Uvl1Yh7NWOtdJ+rZXdNPnjipyyG3D970PwbS1fkiYHJyOoQ6vJ13nNH30VAxLzFo8lDOLfbPn1w12D+ZgPT3MGuvu4jvkwq/lYw5jsw5YJ12lf63ya7lDPLrf8+l7Z+pLT3jypOwAXgzcvtvz6YlfgMx7706R8YHvdPJbxssbjWk3kH+05gc2b5L9OXy+7nCfklN3OcyaWXd15swrEPe9izrjjXAzzuXs7zrdHSbGAW6PtYubiQ9kgdq/KYc8+u44y6DwPcvqDLs7JTsYuO46xv8G3WBGrDpgWRa4WrkX7T3I60d+Xd6av911Glks2ZtPM8ZWt1LPV8Yb/bqKjjVcdK59cVRuYeOJPakjLouqV6lhu513nSUvBhtWKhKLn/DzWy0LnYE3lOivTINZUfkmZK+Jxorq6Upg9z583cWV9x/cVKbvXRTrCmtqGsmVXR/9TqOxi/c/mY+31v6aBYSvBtzhhzPZX0wJ5ke2fej/QbrgtfZHUH2zaNCa4aCmg/2FH2xL62btb6uvTlvLheV0D5TTdlzv6jFC3T3ta7z7u6F/DqoOHJT/vzY5JaLgA8UOL6d8YtIh17LKm8WJ2vHZRw/GENnS1Guy4hSpwlXQXbPplxzFurHsbVuWMIl9iuX/ckR/fBJLjGPVFzQGf1XE/KTNXjGl/kdR/waix8W+NY6s2+qrW6mLPz8lGxy4bVoC35Tqec7nHdavAATytYcJ1mjMhrxph7WV0PTZk58n+t1nkFfLbOm+DyBn8tNbA5jQatU80c9Ky64peobpZ9yC15vr5OPl2aXyVc/BVsuMKbIErDbXXr7YCFgWvFNY2+MgEFesou0Usu6sdZfdb24OvmvqfnWVX44qJZfLHVb2mBhSN1+Uar/yGwdXrvt+m10B7+jS2qW163sLtcr8VrVMd5sPLmBfLisfa6RXxPdMc2rHLfcfhe7b59+pcwdCjOlY5wBonsZcdTP6WsQ961mLdy+uXvhkDx7HLZQuBjk6CPzmrhL8JfLRQT5YxyHHdkzo7j+npxd0XsR25TOoPfOaVyfOmbt2PxxXiDR9Ktqdt50Mj52Rd84aK86l7eeOQ2x1W+vMY7AkFXjUwtQpyfQxXLWPj3uUJPYlXTz8m3z4vo05fGsoQqAqVLZ48lQcdNXzGjzUEFY5rLItpl8dTU57W3uHEBupjTYGH1Tn4NJ6Dz5IDEfPyRczL86YH2w2V3SS2Ux/jJO4Qyu0s0//UVf8fZ/qg44HlxzQGHd7VNACbxv7pYw1t8BDybzXYfdzB1z8NK9O6Hvf0IB/Cd36IaWjSox5WwZ8KTPjqdtxRHTuO7dTjHrYDx7EdfdNR/hxn2oOTnmTLcbbfje1DF33CKl+aLpeTIvkRx41N15Pw2W/yxnVxvtpGnQ15864PdTOOSz4m7QecvqwuDCuLG6yLxwPIh6bGLl33z5MieXm7gwp/Em9hqHup+Mp5HIA97uDYshPjxifiG4IeVY/5bQsdT5FJW52mNZxIVbzv2yQ7Dn6eNlQ/+zj4a7rzftzS950lfwTdmmpLQsDk3dCCRyXb6DdxoNlUsOI8tsdnA8mPF3Ey28SEaBIH229GXKfOY/5NOkzGSdJO4Cmvfeo6H1b1rUpdfp3z+7M+BDrX+qG84307knNtFXhrsp6/3TNtJ7F/nvYgq1ZBjvOetZNdBSWz+fKx67FpDHa1OUe93HZRPOc2+6bGme867qsex3aky7p41oN8OO9BPtQ9dunDODN3fHC75YI+a6HjXGX+izZXIKwFNbqwOuZ3FQaGszoqXcU8v19zvlRduVZ1INWb5xHGzretyVFvrnA1nJdttS9tXCXN1vmPYyu72C7WtbKrSHv8ps+r4GL5trWC5GyM7UHmdr99y3gR+93sazG0SU1PJtbr+bDXeR5vlc4rg6c9qoZ5V/oXY7j9u6XA29U+t4PF+v+hhvq/rKEdyJ4Hl324E6HAbdFdtA9d9UVhfHXewfc+XQ/GdhB460NfFY65yqOE6uyzT5Ju++wxnpN92KAytz4cjbygw3eGlXanDW9LX/W5YHU37CGKfFH2IeAhj9L3zWsY3Jwk+wfypg3kR5XJaaUTsC/PIOyokz2OdfF0TLsitpmXLU04dnWGp2PYHTVnB8PB90F7tm1tX/E8GVmd2mdME447rKya57WJsYxC/1XmmbFdnbdl8mEVYHgf8+O73YPjxczVLtFlNkH5Jk3p5yz2zIfnOccUHpvS+TOGMxuV5R3LGBR9hMvqGdB/j/VrvqntzexC/vu5uU8bXWFus4jpfB+/e7FjDLBqCx7sMRYIQZe/1bGJREvtwyq4sSq/b8bRmfxY/dwnT1bt5N0+9csbrNrJJDOnWrWF+7SLoU0MdW0eL+iWGccuM+Wy2vRwVQZ/Scpt+LUqg8s2x0Z7jt3DMYfVsLO8viSzCrlMneyqLlY5J7/ps2s+J+9V7Fevkm4fSbDqf3bXxR4PUusc8Icrsqc9OpnbmDi/iQG4q5LvfZvUc+vobI+8DOme1J0XYRKz5wC8aj7M+lAZcnaqa0Ooi73cIa7P53uHgbfvBgUDL7PjpNtVOdmg07IH+dFF4G1ok568PDwrOaYJ/XCpYE3ss8LrZWZDl/OCefwmDmL7lMchD94WuSiYCUxeZ87hkOdlNueqUteuY7Bn1zkSyuJZx3matwJvOaJNT/Lqfqgzr4pedI51YlaxHdhnbnMV0zkvmc7wepbZbKnMbn4hWPxzX3ebLJMva+V2ncmTVfswKdM+pK97PcuH0EeEgPn1lnZrtja2OUvKPf83BLyelwhQ5J1X15n0lK2bJzHtT1qKQ5QZu79MSm6gFfut1Xm6OrazonWxbxdpK56Tx5m6UOacfFMlH9L3PUnfv+ov2h7jhjwotMNwG7edTpLuV4VNY5R/sBPxPV3u8cyHWQ3fu++tntOmyr/l41jp/DkrsY52favXcdKf5c1V8vJZy+f7u56U3ZuBF10fzoFVAO64J/lx3HGdejfgdmBSoj0Lg9YQBLuocjU3vDeuXLkXP7PIuKsv520YjN+NeXC95/F/CSKlr3D8D5Pit/ns1ffEwfOrnD971OX5nJnc7PIqGb9wPoTJ2um+9WvP/D8pObfJngfzim1BGIvcTcqtanza0w2VrqrmS8yTl+kr5EkI5BSduJ/0aIOwZZy4341t3bLAca+C6/dK1IWTgn3Doux5lamb90rMJR83fdtl/PzLkufpk4p99jzuantasL9aBevGck4uM+fkRZlzsmo+xLL7Iezouu1VoH6e7nr/llfhOw7aCr71YcLxuM5d1wYQePt9olWmw42R+6qR930b0vsN5cH9lo9jZdZlwXcQLMrLy2kyUHGly9MWv68PAaOVwZZbdNajc+CyJ+noPA0D3hW56CrKsNLtXp23f8YB/b04OM49b7vYeGptMvkwTEDqvD0zTgSL5sGX83/P57+9zBkLrXY47mxMWyD/XybjtjrHWh1rlVxN3dR5sMwE4Yq2MS969NzNRZzgXtScLy9jnhStE097kCerizQvK9aFum4tvo7pme2ZnhCEOy3RRr9o4Vwt4kkD5+ks9ldFApiPO94dvqlz8iqek0UvjnSdD427nRyWy5pO5sfJMAJvvx93yc6l6kBm300XmjrZ9u1Yq6Rn3uXy4dhwPU3oVdtRsOzOB9a+UNxZxwGRPnnap10jC56bzwr2JxdN3uIVV8FdFMzjLi5+rlYjXTd0/MsSebDX5K7g6refOqqHoUzzNlq4GvKt3V2fYwXGA5OC58G9JlfkxUBH0WB0X+5CWOXLrMH2oRfBnxJt5aKG475KqgfgrmIAallDei6S4heKmhoLFLkldxUgf9lgfXxYMC8uR3xOPixxTo56/npowbdJ1avteyw174sytzy9r+H7Tlp6T9Fyn+xRzlXMuiroWM6XCXVqa1fTyUDbF0oMBocWdGoyL4aS0IIBj1VQ4Krp9MTvyJssHHeQx6vJ5LylPCgy2ZzsecvdVUOfW9VZgT5pzLecXnT1LLt4YfOsxHmwaCNdJQIdXa86XuXLskd5Mu1opc2i7ryI58W+m6zM696YI35ekfnQ0wbO1TCPK3Kx82Ebt6wXrI+TDs5P52TLDi34FlS9UjnU5x8dl5jU19EIlTppWjjJyn5+1eBbl897K/PwVfol7yHfDJ/g+B/OBxSILHJuPm8zKBCebVKgv37cYh6HwftFmyuuCgYh95rcxcDJVd2fW1Mfv8tVX3Zab8DzjjeRKNJ2tzaZ3XNi+6ijdrf1fIl5ct1E+1CDRtrKuCK07MWPL6u/mjrOJP9xRk08HuRFwTKYtVwf5wXOz7bmAQvnZPsOMfi295XKGI0eclDjvEiQKw7aqg7cym5WMG342O83nP71PJx1UcBxQOW2tgEqcUWd4ZuO/ZkWJTwawLlZ5OH2s45ugysysTlvKy1trHjb0N8+KTChmez57LfnDX3uvnXxvMA49PlI24pFlzt2Fsz7ZdJB4G1tYps3/uxiReyqfegiX4q0kdOWA5JXDc8Tyu4g+qqpgH383LyVuMc1P5e9yHOmrzoK5D9M8p8neuacbP2cbM0hBt+CB3sOvpuaJMxjZxkGTFfxvxcNfVfRDrdqp1B25dj9hst82nD6s647rNue8zZcyk55H6LzAaSxyMPtL7pIWBw450202ghwztrcbXLPyeaDPfJ3keSvJmozgPyoQDksRtpWdB1ULNJmP+zBs/byJvdf2t2WJ7YvuwjMZ9rIInXnbCx1OQb2iuZ3G5uzXBX4m2mN3/eowDE/6ag+hvb5VcX011ImXS0UKThuabtvbU0fgm+z2AhlXy+TZp+ZdbbHks4w+K5zGegiDtZ/iLs1hStlz+IuI6dxe957Sf6OW2UVXXFR9blvZTddmDZcz8o+961Ket53cSIVXJ1Rh2U8P2dJc0HigxLr5rTlslvK+U7zpo+r3+axz1nvk5vsj48HsAow73EVr7oMeMSr94ucPG56YtlpYCROIvLq6b558KoP53L8jpM+l0ODFl3ebhrPn7wxZGeT2Q0T2yL14LzFZL3qOE9eFhivtrWBynVL/cXrEulZNpz/4XjzLs7cr+lcLTIXetJxkDxvbn/SQnC86z77qsA52fex4V66Cr6tOoYfMkGn7OtJ3Knmbvy7Jk6QackTuc7oazi+u6Hi7Tr5w1WieDtFmS16iyhyLHV830nB/G1rm++20tPV4KvJgVQ4plWweHXeroLEPyRfr7R2NjAegSav7lzF8lkvux9i2V0k3a7W7NJ1Tt40Xa9/6kEerPrju/FC0JMNffJppq502h93MOk+yZl0t7FqoI6B9IMGv3vRh6BDgcnm8T79e1yxk3d8bVyhz1t5NetJOTTVVncpr63ubCXNljp7iMGmqnXopKVnbb3t2TnTVnryFibUNQ7Iu8iy6Pi5kUV30z47gHPyVU/OyVZ1EXybxUH+s7yoc9xC+1nydQVY3cuV75c8keso/NWzIF6WPUlLbtGbezx5EfVYNlXzfFrz37VV5lWCb4uultY3NPgP5+tqZebGYHGsn9fxWSN1B4oPxXmDbe1FLJ9tZXcV25d7SYe79HbQD4V6/TAnb5qu12cdDyxWD8B+ljcQW9WVhvLifo/rSt4E9boHt5mtJlrLjvrZXrT5BSdU++bD8wLn8qSpYyu4OnrMO5y+7+qLYxudNxF+1ZN2oEydnbS06vhtT/KjyEqwNhYDtDLOin36si/pKfI9NY2H8i409aWdvKp4HINsT/cYO0yTkWk7+HYdJ/GlOqjYgJwm9QbgTmo8kYt6UuWqZIkdQgpN+lpokItuWtDWxKvoCVxlAN1J8KLA6ox9vIzn67zMuRoDOb25Atx38XaWugMwT2LZLUqU3TyucHo58izvU70+7nBgsQq8lepXG7gY1PfB1SACHnFcdZ0z0Z409PXve1ReeX3wj3vm76zAZzf5HMe8z150/My9NtqrvrYBRSbSXbQJIU15Y4AHPTgn28qPedKD29xaXnGUd94s2goaFxxrnLRwvvblYtEip3ymB3BOLgqckyfJyLQZfAuZe1GhgFbbINfVSBSq1AWveBVR164qdd32U6TDrXq1alJnWdSg6PLVKsHAriYhdefh83jL877n68ukoweQdzQpCMcb8ut0x+uqgfq2sY0ou7p2reyeJOMNnj7pYb1+0EE+fOlPKw66i+wwWVgfd7WK/cVJzsRl3qMk5/U/Jw3Wp6HkQZV6lhdobeQh9vEzz/P67DF3sh3fIpXXR1/3eJOLvEDDdORlt2m8tsvfGv7+Wc+Ot+2yabSviAsRds3z5j2rj29zjmfa0DnZp3FL3jnxYzIybQbfKj/cMJ4wbQ8w6qr4z2s6YZZJPVfYpgW+q2onkTvQj4PK456V5xB3Oq1zAn8db/euWldDPR3rKqpNz8kKK6pmO16LFga/L+sI8scg09hWUVxVCUqu1es6+6FpB3lReYOAErtVFTXpYZ3J6wtmPUvvrOLx7FsX+pQP86byIK4syztvzhs4przP7PwZRiOX10a/7XHa8261HOUzlXb4+wD7oSr+0bP0NB30ORnYuTo7sPq4yc85v/fMtz3VuRz+Kqkpcl4wolzHqpSrmiPtr1s8/uuGv6PtiedJTnonFU70eYfP/KhrUhXSX9vKnrjKaJGMSxg83C3ynKyWyy6kpc6gUFMP1+9CrYGiGJyuaxA56WDV18ua8mFWYz70cYCV1z/16XbLIitMRncFecu53mQ9y2tjH9UZzCi44dfrhC7HV7O+JrzFW/2GNH5jvCYDO1fnFY9nDGaHlgdtBd9qGxgUeK5J251uEbVG2mtcLlrk2N43/B37Bjev9nzf/QbLu5NGvebVg008NHhMt8PM4kq3Ni8AFM7nOsuu4G5MQ9HEtvJDXfVV9wYBdfXvQ5wALgY2kD2EFS6NTq4LPEcr5PHjGr/ycU659WW33VEqsDvusse3nBYdmx5S8G0pL0Ytb47Xq+BrHIvtqpN/U6TjC74d9aThLysEhM5bSvu0h8e/GvRXrZB/ayHtPzaQv7MKdSDv+04q1suhN0y1D+LDZCUdwD4dQQO6eu5knWpb9dbQbUehPjwa+KS9kQs2YdVXWq8XNdXradJe8L7udmqWjFfeQP5dWgcMjXs2mWmhTMIFpcsdvw875D6r6bvydtvt4y6bY5LX9w1hJdU8Z+x7rJjlxYH4ZWB99kSRjU8rK98aeB5IK51djbcChZP9tzpfNZ2QJwXKrsjuQHt9R7ydYp/jeF+lDuSsNrpfoZ539YysaU2fc93gIH4Mzw9rYvXUcZ/zt4OVxo3UvQHU67+0PBGrs464jWc4rOqop85fJbtXK4Rbyc9rGIOeFxgjWfXWrLw+ejGAY8h77tdfFDP6OGjH7SEmusXB/kQV+WLWUEM43Tc9sQ7sO6GeNtBwz0ZQzu8H+tltaCoI9aOyG3S9ruuRAm0OGJvoPxcJYwgkUFzeLflPa/iOvM+4suqt88n8zwM4hkXFYwR9HNSkjeDbTDb31qSNyeuOlWZ7rTLLrKTct27d35LOSYWGu8sddOp6JsBcO7A9/Q1Nco4HUHaLgZddY3nTs10ei6Z5qY4cLIGa+rxM8le/nVUcN+WN0Z4rBrTPAMNxWxbsNHF8X1Rd8bPtqtp0j8/KTnb3DQpOS6azbLoGWU+bDCSM4Or83/ucuCYf+DzEANNa+t0WCd33U6NScEOaRxW+osiqt4WSABgtbfwICb7tNpEFvw8yq0xgt91at0+w630dE4ktO1jtG3xbmuCPvhMxaUXdYMhCP26lVL3ynrc23WdH6zg+yXvfa9mPuQzosxmWI1lAiQnmvsGpkw2Dy2mFdHwRAl7p54TGaZ9b98L3rwfM9t1s4Vr1KGRhENgIgV/orl8cStv73EqpesWdVa+S3TuvP9qjnuStmJsNfUXywMYtuwxhs4JJxWOEodg1J6y6kKTtcf1zz/QcJ8E3jVRR4Zlmj/f8nk1Bu+meg93ZhsnPPs9VCYG2lwXSWcR7VamWAWDfO8K+8rDkbnnA74FK+6NTuXDwwsqE8x2/PwvPky0a+IzPnj0v8J20I6/cxtD//qyYGYn5jvnlUp9NH7jttFqnO4ZGqugkY1blizasdNtnldmmNNTy3LeKmy3MxlAZ0jxoOogwGfAk29Unxjz5YrP3OW2msj9wMah2lfNnZXY+zVv1NrfqrVeGMK65r5jAnTf0g+DbbgtZ8I0qt1euT1KmNU2E9h2EHq9NnPZtlBc9uJWnrlVZjU0kWwjsHbQYPG7qs6cDzxv1mn3lBd0N5gnyVqKdF2mjY3tynvNnr2R3ewoEOidN9r8tje1mSpqRyLtgNpVFdD4vkQWt6GvHVjZoExq1sz2/68caJsOzDQOj8Ny3fY9/msmDfRvkPjzv7R81DtCaqqs6vM0WNebvVUNpHHqA4SRp7rZh9Xrc8urN/cQzPw9euACXjkNmOe3Befp6lvNR4dEeuwL64WLflRzvpB046aj/rTbJ+zrePi5wfHAIY+om5zlQrF2WBc13SCO6x7xKg3VSdcK64wrkbM/P/HHLf5fRh+e91XVL5Kbn4CU1fjbf+7nG/G1q8P9g4HncZN7UVa89N3KYY4BwMeqJbCL5uvpt1zjk0dGdOy9zHmHwqMB30E07cJLTR171NO0/5fx+4bEaHFCf/VOD8xwoxG2nO9TVIQ1gSXrR/AiN2mLPt59UnLDOGpi4Trekr6509aWzKeqswbp6lrBx4Ftj2dV+C2T8zKGX3VmDt4ee1/Q5Jj/9HQPsal8nbmMh1pVZznggtEGPd7S158nuFUqhLlpl2Y28MeZZjx9BkNd/zxQvI2qH5znjqZOxzMkZLsG3fHV0TFP58c299vvkx/sG0vTlWR1x0LRPYzzryRXDOm8ZOK87cXFSobPbbFHT5+yc2FXweAR53EgAscBkuatzmHq9zfn9T7KI6HmFupK3KcMrK5Q6UyTo2bu+Mu2jzgqMvd4qXg7sfD2XReTFB5r8cMG3diZFD0aUH1VujzqpsKvobNsvKu78NU32X/XWi1vF4oB8UdPHParzqlAMbD5NaKLubiq745rL7tFIsvpFA3lTZ70WfBvwQN6VdDLt+a6+eBKD9uvtSV6QJPTxbpXqdoyV1w486uHqt7z+e5kem9WUjM3bAZ6r9EujYzrPfMsXAixVr2h9uZ2vjl0xa7zFZd9dOkNHfbnnd/6Y7Hl7VYEgRfj9Pnlzv8JJ1qdBy7ymxuI4lm9dzyl8mlj1ljRUd7eV3cOa0nWZ1Leyq2t1582LGuv13IqWXk+8w6Y+ec98elFj3WLYnueMkUKfeLU+Gcz5zCttRC8m9Gc5fUwo2148AzIGefPGFQJvjLHPvk7r/3LH+HV1p8gzuXWwFjm//7HJL7fyrdjEuK7JWtXONHSk72p6ne/ZqOU9A2eXMHm531AZvK+Qpn1OsmV8tkCfBoZ1maZ17bKG+nqejOO2xabVuYLyrKaye5aM7zl9Z/G4qubN46Te2xZmToHee1Wgbk1lE3E30l0D+0lc6ZYd100r1j/aKde8AOjjuLtop+KqniJzDvWKQ+2zn/bhXKUzeZvdNTqeE3zL73Dresjt2abbDRroTIuqckz7ThZPkvqf91ZHmk5azIOm1J2ecCvV5b5Ls2OA4lIL0vi5uLXsKrQ1oZ0Z663CT+PxVcmbFzWnyU6n45h4v3ErC1Hes9+yK93ynhl4VcddE7Qyoe9LO1Bk1fqsZxeQoU5XRc4TffbBypszH1eJ2eQRfCumrlVFl9krniWFCV9dUfpFxU63Sn5MGjhJqj47a9JhnahrchgG53UPpELD867Mio64gcW7pP4AxZgn9lV2Ed5admk5fChZdmHF44dk/KsVH++RNyexXtedN565Mxx5AZXj2F4azGvTw8RvV7B2GtvbSZK/iva5HO2NlwX66lCmb7pKYIlV608UJyNugxcF2s4wp7ZI4DDrR5GYQWPPvBZ8q2cgVcabMrc+xWDGh6Te25xet1Bp2z5JgjbTNethVW3iFoKTOKEMr40PFg+TzRBUTl9hwPkxGdfuvm153ULZHW8pu/MYWHqX1Bfg77uyefOhoXp9peoPZhxQZOK9qledBOAyAR363x+HgX3eCuOZVW+9agOWSbFgaC2P7tjj/D9Piq1av7LqjQPwssDc/ayLc3Wtz3bBrht5F75P4l1ctRN86yawEW59+hiCcNvuOY8n5GUMZtQ5Ia5r16y2VmvMSvxtW4OJRU8HxNdJfUHi7waTydcrRKHe/haDFuH1S/pv4RUCb2eaib1dNfjZq7L7JZRXpux+i2V3mRxuwLTrvPHMnWG5KPA3rQfg4lgi1Nd3sY1+53k2vZ/4nRXoM61665l4Mb7IuHS1+vy4pTbgRVJsFU+ok1a9cQjn6rJgn13pMTt7nKvH8ft+i332auwpCNeuInewvWhiLCX4Vt9AqqxJ8vUK1YcYzPgQT76PmRPyvInJXk27ZrX1nKL3PUzTrI8VNJZrW5P5aXzpLOopu0XSziqo40zZ0W3eXFvVMrjzdJYUu3h1Evv2RutSZmX807W2OHyvZ9D1vz/eVT6ztu8yoLCHBecDjbcDcSJf5pEID+2cywG1w2FRQpHFImG+3fhFq/j5m+b3X/psJdZq3QhzriJj8Hd1t+GCb+UGUk1ehVxtRjBp8DvqWvX2ZWDYUtbPepimtz2uqnUHiWmPVQ7Km/6PBcKqkSKrrCdx0Pai7iBYnHA/S77eDn2y4/utRh5uf/xa9vV6PvCw4J+v2oHLBtqBEHAr86iP5wK6HKCw+m1RcB7+Ia4k76LPnto1vZfj8NXzfGurF4Jv5Trcl0l7tzY2UsnquuLV0EPiN33PrMTfLlsqn1mP62ibq9+ot+wWSX3BcfrNM3eG7bRE//dlghwHbpOKA/hJHMCHCff6ardtE3+67Y/3eUTHIl6Vp79lO0uK3dK2ch7bgRdV2oHMs0hDG/AiKX73Qehznik5DrQdLrpaNUn+uCutcrAlbtb1ItNn5/G4iHbrxlWJuMHTTBt+VqVuCL6Vd5EMc2XRdQwe1mnWcJpnPUzTvO9L9uMAy8R+mJ4nVi6OnWfuHN5g/jgzcAu3gz4uentLfP7rs3h7adGg28pCafWiTW/jPXQzcSsTgAvn7SoYv5rcTwtO4M/jplarZ5FOSnxvCLxdKDEO+FwNc6LTEn32JPa1v8Q++7xkn/0i9tkf4jlftM+eKa3WlYnrrNrwN7Fu/Lbh9SbvAsuRPC9/AqeZ+iQZ1vbEi5IDhKLCM9bOG0z3+z3f87jBNL0dUGPywRk7vEl92r6ESf07uTHejt4zd0YzFjiNg7AyE+HfH7Sfvj/8mG8Z+IVBXpWr4HOrp3pRTxZpOV+VGCtZ9Tas8r2K53HZOcFJfD2N799058Ykqb56VeANvu2z3yXlnlddtM+uer7O3BHRWb2oM64T6koIwN7dNta38m3PzjYZzu1hX67QNzTZa3rH01lL7+nT59fWmCTNBFxpvuxmidtPx+plfAAwIxm0pT/uJdVWGq+e97r+qhJ4C23IqRLqjTIr2TzrbZhzgjIrYTc53tAGTKrWO4E3+K7PPm2oz65yvq7aELprw+tccR7a8/NtvxR827+gniTt7E5YRRgInDYVSW/6GWv7PBi24TQth/Sw2tiY9KWOzhLLqYfavgy93PqS/lksV8Z1roZ+4V7Sj1sFv9zSnKbn1OrKXtWRRVLsYmWdm2LRbhmH8q0aiK977P9MycB35+oqAHfVk3M1LJBxR0T39SK0l3VerHiw7ReCb9UK6qLHA6VGA28tTGyrfO58YMfadB3tuoMJEw9XdPYru7myq+xhD/Jx7hw4iIHbaYd1LbTz9xp4tiv1KLIR0qsBTcBMFL9vAxYxEP+kw/wJ5/9du5rCznN1GcfYZTZPaqLPvtvA3RBDa5uXPaoXV0n1Vcy5BN+qF1ToZPu2CcM8DsLbmAS87eHnvm8oTe8HWke7DMA1edvzIbQv95Rd9UFWG53pDmFgZSXSYZyvs3jOXrQ4oL+K9esirrBqwmJgA/3epTcGQ2YFyrIvdqV12cD4crHn7/rYDnwJgCXtXpy/jhP5Jy33NfMK9air83CZk49NnTdd1OVFxfJrYlzZtz47nKttbnZ2Fc/VRla7xbZ52aMyH1R6YzD0bg1twdaYgeBbPQX1ZfDbkwodnil0r8FB+KaOrO2BX5PvHcwgomQ5XSTtPwNunrSz+nLs7ctF0v4tbaMqu9ge3u2gjQ7tseDzAY4J4oD+oqF+YxHbhNUAvum+adft0q96WARP9vxdp+lqa9xW0POWy/z1nr/raxuwjBfnf4h52UTZLjMT+Ydd1J/Yt70cWPvwqsH05gUS2q7L1znpaXsTuV3H39mjfcLK9fT1Q+yzmxgnLmL7/0PDF8qK1OPnAzsnn3dQH0JdDBft9709eWe7KPhWX0HNM8996WKiNYuT5S4GlrUvma0y6Y+NWt0N22LogYgYJG7rmSSr1T4CbzUNDJL2lsePsuziJOE0aWc1wqLD9pgetbnh+WvJ18DvkwITobxJXRhfhItrd+NkYdHScVwn36/wD//9vI/PldqR3idd7iSaedbQYkO6XvYsD8OY8uGGtDZS5vEznw+ljpWcxD2Lwfh7sf+p0rcu4mQwBNvamsjnHeOTLWV30ccNhrbUtUXM01lN44xN7fzLtoNLOem56CA911uCKat09qHPvpfps6vkzyx+xqrPftnWhdgd7ekQz8nrDtM1iwsgVoHZ6wLzsOtY5lvL+taudx/duRMy42nFtM/i4LNWadp+q+FjTptoeNK0hV0uHqevR0m57Yz3HZC/6nJAmR5vONYXdU7+Y8S5SprClsHnNaZpVNu1xzJ72kD9XMSJxPWG7wzbe08rfn6pgXj6neH73tXQAN/qSbk12bbsKrs62tuyZVdH/7Ox7GK9CG3EpOY8DJ3tqzjIXtZc9r2ty12c2wNvfyex7q3y7C/Jt7ubhn79H/GcXPTp+U0x7cdDCc73Nb1Dyse205p+30lsq+YjbwemsR1Y9UM/rvXr7zP9SsiLed9XUceyW/ZsFWfr6Y1jtWls15dxXrPo8DhDes5iXetDeiYxPcexn7vuc92O9WSS6af/tjZ+fJ8ZR/etzx5UezqUNiSeUydr4+tC5X6UULvYgIRJxLO0cM6TrztenNU8wQsT5Nc9OcHrTsP7mj7jvGdp6lMdfZnWzatYL5/WEIRYxMnzlRag+bYlLbtw9TwE4X6qoew6D+B3kI+hzbob2+dH6x3onvU/3E7x0i2mFKh/i1hnZgNNu/QeUD62ndZDWTE/xk0RhlZ2TaU3jgOuk/rvDKqSnqse5XtoU14OrJ7M+1KezsnenFN7teF5wbc6OoamOu3nPU5btnBCY3eVuQpyP070piU+ZnXVKwSAZn3rsMOJkh5fnfdk19G4zZJ67xMfXINbojO+ilcazmL9nJbI41Anr3vcWC6Sfj7foI6ye5Z8DcSFsvupZLtStuye13RO9i0fV/V/Euv/g5J5GPLudUv1v891+XVS/QLF6CaiAACwcksWdGfTksUNk0MTErqom5Nk+4qqxT5XwtPP/JhUX6V1MLemVSi70KYc11l2HR1HKOdGbjutWP+XnmUIAACUmmPIgu5UWbIIDdfNRVL/ytCJnG2l7ASG+ln/AQCAA2W3U6BxcZUnAAAAHBzBN6ANJzV9zkxWAgAAMCSCb0AbHsgCAAAADpFnvsFYTuZ6HlAfdr982EDyzur4EBuQAAAAMDRWvgFZZ3U/ny39vGlSz2YLC8UDAADA0Ai+wXjMavqcy5rTddmz4wMAAIDWCL7BeMxr+pyw+u28jg9KPycE3iY1peu9IgYAAGBoBN9gJD7d3CyT+gJwl0d37jyu8gEx8HZe4yFeK2UAAACGRvANxuV1jZ/14ujOnXfxmW2Fhb9PXx+SmgNvMbgIAAAAg2K3UxiXsDrsRY2fNw2vozt3woq6t8nX564tPt3cLH5vRL5u0HASXz/Fn3V7q2gBAAAYoluyAMYlrFZLvgbNxmL56ebmByV7cPX4WfrjadXPSeuOfg5gmP3AJPn63Ni51e975d800xfO5AhAx+2yLIDReZ6MK/j2SpHS0cQlrOIsspI0TArDhiDX2VWhALEtCSvEw3NQw88naTsxlytb82qSfL3wchbza/XvoW19nubdlVzamnchz36KY8Djtd+t+qpwh8TbNB89RxdtsjaZllkRAOPsVMay+i0MFO+64n2QdfhZ0vHKtz3T8DJOENVZYNWWhP74Xfzf0D48kysb8+kk5tPxjj8Lk+RTbew3+RaCbuFC0aTE2xbp68KKOLTJh9Umx8BjOPaTOM86FXxsjw0XYJwuxnIcBtgMTNgl+F0c3ABQbEI4Sb4NvC3S15P09TD5elFjNRYIE8ZLOfZ1Ep2+3qT/GV6TtV+HyfQs81qfXE9iXyUvod3z9iSct+Hc62iseJb88Xzu8P2PlEp7BN9ghOKtb08GfhjXbougR8KV0Vvrr/Tf7yZfg92zzN+uVm8AUMyj5I/A21XavoZV7y/DOCB9PYlt7WI1eYyr5A55Ar9avXKW+ecQoAyPHgl5dy99nWZe99J//yH2V4vMe87Tz3qs+kFrzuLrPGlmk7o8FjV0SPANRioMWsMAdqDJXybjWb3HuM+zsPtvmCieJt8GvMOVzXM5BFDINNP/P9nQ1q4CS9kJ7EFau21sJYz5QtDt2bZnj4Y8jP3V3fj3KwvVDw5m3HqdmR/OkuEv1hgUwTcYt9CgDu0+/tXzB1yZYWgDmpdrk8OncgWgkFUgadfOplbDf3WZfBt4C4/oeFJm3BRXE4bVcPfcZQAHN169iHdwmG+1TPANxt24fglkJcMJwHnwJ0OXfTbR5NBvjQIoaLFqN3f8zeTQMylurpBd9Xex7w6wYaxlvAXQHsE3GLlMAK7vVzYF3hjL+XZtsghQyqrvn8SdCDfJBp0WB5pPLzL/fbVv4A2A9h3JAjiYgMDD+FDdFz0ddF8IvDESP2f+O6x8ay3wHVfahQnq/Q3n2Nv0HJt1NuD4upvh+Ya0hUn0++TrJivLDtMX8u1B8n3A9G1MW6eT/b7mX6xz4Rbrv4fnTcV/O45pfbCel/H27LbS9VPy/QOtw7nwug/9TQwy/ZRs3qmy0/O1A6+SP4JrYRfAe9n6HOvUale+ZXKAt6DGNmqSyYMnAz2O40w/tV73Q1t21VV7m6YttGF/C3m7qn99P0/71Ddk+oPXZW9nzrz3fVv9xKGqUk4V269wHj1f9b87+ulFPLeue5Jfk0ybld2hdpk5xxZqFrCxwU1fYXv533ryetHRVtv0u54+q6N+1ZiGZyXe9yLzvvO2BgYFz+sPbd8KG87v9HVZIG2/dLHrXhgQpq+PBdJ32UVbVaJsfylTT2tMXzZtXzYaiWnZls5pT/q4d22dC+GYs21JH9PYk3b/3VpbdZxpQz7s0x6PLH/eDDkPYjk+y2kfsnV/0nL6BnWe9rFvzeZX1b6kzbJuuW3LK6uzPpdThXFM9nw5XmvPtr0+Nj1mqOkc+y0eT26b5bZTODDxGR/hNtT17ebbNku+3mb6xMM+GZlWb42Kg9QPyR+7BWa/e311z5e/bXkn1rAr3/mGtM3W/i1MtEPg8rLFgVVYCfwm2byiYb3swjG8azMAF8tpU9luEtL1NBu06EC4kn6ZfHtlOGvZ5DlRMr+msTzbnjQ/iOdEn9PYlYeZNuskHvsk+XZnz6vVCssDlK0zV0NKeKYcn+5oH9aP9UMbgYgBn6e97VtrcDziczfvuMfY3k/W/vtjUmzH6kk8t87bTnA8nz9uOMd2jf1zL3ALvsGBymw3Hwa7bS7rDYOC07jDzkxJMCbrtwU1XcdjJ/8uM1ANA+8QWP8hnN/pK9y6dWttUhtctjFRiFfbs9/zPJO205i207XJwnlLV35D2h5vaJtuxXwL7eMPMc3LbECgpboUBuvZQNYypuVuTOOtTNlm2/BV0KKLycvZhnp4K/P6oalbMzL5lWxLQyzP7IWn4w4mzSeZMg0BlIdr5Rl2oHy5NhlrfRVQR+OS9U2iVpOfbODt4kD7lmy9WQzpFqfYFr1Z6wtC3b+3VvfvrrW3X97X0cqXIufpVVfnaQxG7NO3nid04Uksi1ny7QWoeebfZ7FOXY08LyaZc2sWxzA/7GgHVmPW1tqBDWPrJPbLRdqsdzZbA4o0NGFJ8OOCy4DLvj7Ez57IaQrWx8HddhpvUcneTnPZQj5tvE1rx99nl89/aDl9j0uk7byF9u63EmlbL9tnDafveO37ipTt+fot/S2dq+u301x20F4cr906vPMW4Q23vDRdntOytxZ10Z70KViz4dbEgzn+AnXo3cDS/mat7k8LlP+Htfcct5zHvT5Pe9y31nXb6bTFsn7W8vnwrK3jbKKcajq3itTb9XbgY4v5s97+nBRoBz6s3S67sc2y8g34IlxFDQ84TV8PM1fMwpWaEOmfJd/fvrZN+NuwCiNcCVhdzbgXP3shpxnhpGgSB9whmJVdpfSk4e8Ng7Zp5vtO827hjqtGfl9V0uYtPXkPUI5puxeP46rh5DzN/PdVgbTNY5u48qjh9L3I1KV5wbINeZZdFdTFBY9FRyuTwiB+ksmvnY8zCL8LfV3s366Sb1eateF53oOkY517mPmn80O4gBUnLNn6n2TaK8+H/er9gMoz9FHZfib3rofMCsjVmPE4+XaVsvO0v30rFPGyQL1dxnNr1ZdPWror4jz5Y1Xpamw9LzhG/D2t29oswTdgW0MyiwGzJ3EJ+72124e2vU5jAO9ZGLR4nhsj8VO8Urj+ClcN158JUSgQVoNsAKjMsxOfZ/77QYuTsPMC7c68pdvRzzNlVShIGgdXq4nLcVODwMxOgKXLNk6srrfUkVYmq12dn3vmV/jbi5b7qUXRnfziuZA9H6ZjbmRj3c8+x2qefP8MOAG4JPnLkPrOtQn3vGDdD+fkRYdtWdnzdN7VedqzvhVqGyvERRtXmX+630Lasm3N85Jt1pMtbd/vBN8AIN8kDqjXX+vC4Pa0aGdd0TTT6V8VfdPalfymJwlvM//9It5+3unkee02j7IXCLLHc9Jguf6+6m2PCVN2UNv2w8oXHZTnJPlj1dtiABPMsul7v9YOjVIm8Pb7892SrysJ1p8B9y7nluJpMn5Dep5Qtg16VeaN8VxetSnHLZdt2fP0bcvn6eu+9a1Q0LyH465sP7T+bMoybVb4++xKve/agiPlDwC1eFL0SnlNfn/49h7PLFnECUKjk4SQH2nafkr+eHj1izhRmMWgwjwOxBYt5lt2AjcpmXd/y/z3jy1MrN/ukefz9JiWMb8nB3DeZY9xPoD0/rxHEOBpw3WuD9Z3NL3ITIhOM79fBeC+WV2cDd6l/z3GjRkWW+p8b8WJZ/ZCwj7tfLhY9DjTNs6cp18n+bFvnfaob4Uiyq40b7MOZ8dfsz1XxYdz8CzTVn+TfsE3AMgXlp4/2zC5eJf8EcwJA+FWgm9rKwAmybfPMOuVcMt6fPh/9vkX00y+heMJg5NwJf9ly7cAfpOOktpYZbDvRHO+Oq7wIOCWVmL2wd9HfnyjXNkS24eTzITnYq0NWRYIwF1mPmN0+RSCKNmgeghsDSCwMqkw4V75xwDr/3FLdeK0x30r1Nn2dfHV+z5bM4xDzjLn4zfjOLedAsD+ss93OMnbvamHWgnKhGdrJV+3ZH+SbA4ohUlaCCB+HNAW7UN56LlbkeituDpq1W6uHrC9qQ1ZPYT/u1tQ44Y3Z5k27WKk2dXl8xzpoZH2rTBagm8AsP/AN0z0ss/YetrSTmfZoNms4GYom173Wsyr1Y7Kp3FH5XtxknyV+bPjOKFua5JwUSHvnrWQvume7zvUSdbftEqDk30m2FXeLrXJ9wG47IY3y3hOj3WFT/Y5X+cDeMbXYq1tp52+9W4P+tZEsI+B23dzh523nQu+AUA1LzOTjNWzV5oebC+TP27jGeQAN+6+tno2093MhDrkYZOrOmY1DK6aNC86iNsx4TmkiW52gj/VHA1Oto6/LdBurAfgVnV9tcv0aG+xXtv9Nhz3Zc/Tu8j2U3sGCx9sabvZke87+tY2H1Eh4CqPhibbf+w7tt75PsE3AKg20P2y2iLzT2fpJKONXSZXtyCF267Ohz5ZSL693eyswe+arZVV3wa/6+mblHz/owM7/0LdWcT/nRzIbpdjMtmjzJfJ94GYbD0Ys+dr7UPf2/5sOZV6LEM8l1cT2eUAdjIeQt/adPuYDV48KFHWx8lhXjyxOrB/4/n5vmPr+Pc7+zTBNwCo3mGHScFV5p9etBDUed3y95UWVmEVvfVk7eHhTR/LVeZ7LntWl5ZrdemyRH6Hycv5AZ6Cr7L5NYDb8fhD6fM+TnAeb5jEvht72ce+5uVafd/rnA/va+E5pdlz82nR/iCWY3YV+bVTZRB9a/ZZqGVuje7yeblt7yK97PC7aWhsHf8ud2Wp4BsA1ONJZlA1SRq+vWPDLUiFJp5hshUeUN70JDWu/vsQXkUmh2srlpq+dex5pqzO4gPb89IXVlW9aGlTjezqlmmR8or59+ZAz72rJLP6rci5ECevb9LXM01Xp7KT9acFzsNwrmbP14tkwyYMY86w+JD9bBt5Gety0UliaMvexHxstE1b66eSpMBzx+JxvEkyq97W2sSDtta3Pi7w9631rWl5XyffPoajSFt8nrS/Y/tyrY9ts83IBpLPhn7nwsjHE0Xr8Je/Swqs5BZ8A4B6Bp1hMJfd/fRxCw8cvki+ffZb2NHs2aaBQlzlEB5OHlYThMFe00Gkk7XJ4btNt+PG3QofJ98Gjt42XFaLtbIKefNhS/omMUDzIebZi6bLNaYveyvzeZxofbeSIKbvMg78jjdMLA7l3Hu4Vvd25dezmF+hvJ96MHinrpNvnwv2ZtOt1iGAEM7R5NuVnWFzhTBR2rgL6sjz7XQtkHIW2/+t7VMMOF/GtuysxbRm+6njeG4+Wy/n2Becx/RNM796srZ669Bl8+1Fn/rWVXkVbItPMkHgtvuM+VqA5TK2MdMWvjt872xtfPRi9f0tbdrF7vHExVod3ji2zrRZHzNj3tmuz78liwHomzg5rnwlNO78VUcanhfd3TIMhDMTh7AT6WnDeXWSfBt4WZlnJjzrA8ovwYomn6GTuRK4aSI4ywx6138/b2sX1jhoutyRvkny/ZXMkK+nbeyouCN9q7LdlL4waPwpU+anDZfzu7a+q0BazmJ+HZfIr8brW5zQvSvblmx4b+PtSUfltqmez+LkeNVGTNbar282V9jQ3lynv394AH1luJiy6UJK9tlFm/qAldWD+ZtO57Z+arFWzutWAdY28nIQ5+nA+9ZlLO+TDf++zJznjfclsb/YtFr8ZVxd2uR3h+P8kGy/DfhukwHnbL9dZZzc1vmRvv+3tvvAHXV4V5t1kXx758t37YiVbwCQr8wg6KLAhKc2cQIadjRbn6CcxO+fbhicNz6wDcGpONDP3uKZzZfphoFLeJZRa8GFzKqZxZb0rU/4nyctBd5y0neyIX2LmLarCnV30OItT6fJ91eeN+VX6/WtBsuRlttV8u3qqNU5GCY/Z2vlNosT0/l6e5N8vxrsEOr8ky11/jjTjk239GkP2wi85fRTky19QTiee20F3oZ0ng6ob324IX3HW8p6vZ9btpDG6w31MUla2AQhBtZ2tVeTAx5D96lfurehjDa1Wav2NLznb5l//658rXwDoHfiFaefaug8TyukIXSwL+Ig8EmZgEsm/e/LXD2vId8mccJ6P/ljlc9qBUR4ttJVF7fvxCv1Z5l0ncRB+CK+OktbJo0hfQ/W0re6NSXcqnPdVtBtR526nxn4rSYtX9IXJxLZY3nURv2LV7TDVd5506sF9kjXg1iW6/VtVZ6LFuv/i5iG5+uBowLvv9z3vQNr949j+/Ug+TZgtIh1/XXeRYP4GSeHuDNmXF3205bgy2oiOF9vLzpI565+apW+WUf1b1Dnad/71kz6Vm3xZK0u/n5OZ/qStsdN03jerNL2pM12dm3s8aW9azoo3uYYIfOdz2I9fVW2/any3gbqyDRTh1fjr6vM337MlOW9MffZAAAAANCa+My+3+Lrl01/47ZTAAAAAA5a3ADj3R6bMWWfVX0tJwEAAAAgI+7C+/vqtaIBuHDbeeZ9v9m1FgAAAAA2OLpz58NaAO5ZfH7hpr89Tl9v1gJvj7d9tg0XAAAAADhoMdD2Lvl245qwKcwsff09828/Jl83FMm6amsXaQAAAAAYpLii7cXaira81+O8z/2TrAUAAADg0P36+fM/09d/vX109D7+0yR9/XnDn4YVcf93+nr46ebm/8n7XLedAgAAAMAGcfOF7LPflp9ubuZyBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGLX/X4ABADdvGiZHZ1RtAAAAAElFTkSuQmCC" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML and GPX file of all sites is attached to the application and can also be downloaded <a href="https:/github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/docs/sites_peace_2025_20250725_kml.zip">at this link</a> (or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a> if this is not the latest version of the memo). The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
