<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABN8AAAGRCAYAAABVBRUGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAV3pJREFUeNrs3T+UE0m+KOiEqXOYtabaG2+Et14X3l0LlXfXovDuWl1lrgV4uxZgPguwdteqwnr7LApvn4Ww9j0LjXc91N5dqzXe1DnQvRkQ6k6EpMxU/k993zk61U2VpMiIyPjzy8iMJAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgKM7d07S14sepec8vJQMAAAAAIMWA2+/pK/f+hCAi4G33+LrXAkBAAAAMEhrgbfOA159Sw8AAAAA7GVLoGv1mnaQnuMd6TlXYgAAzbstCwAAqguBt/THu/R1vOVP3oRgWMvJerMjPZcCcAAAzRN8AwCoqEDgLYm/e9Nimp6lP6Y5fyYABwDQsD/JAgCA/RUMvK1Mbh8d/ePXz5//Wwtp+s8F//wsTdPPaZrmShMAoH63ZAEAwH5KBt5Wlunr7qebm2WD6fqQ/jgp+baLNE1XShUAoF5uOwUA2MOegbck/v2LBtN1npQPvAVuQQUAaICVbwAAJVUIvGWF1W+LmtMV0vOxYrqsgAMAqJGVbwAAJdQUeAueNpC8xzWkywo4AIAaWfkGAFBQjYG3lVpXv6Xp+6XGtFkBBwBQAyvfAAAKaCDwFjytMX3nNafNCjgAgBpY+QYAkKOhwFtQ286ne+5wWoQVcAAAFVj5BgCwQ4OBtyR+5lkNaZwkzQTeAivgAAAqEHwDANii4cDbyoMaPuOs4awQgAMA2JPbTgEANmgp8PbFp5ubWxXT2tQtp+vcggoAUJKVbwAAa9oMvMXvO6vw3pDGk5ayxgo4AICSBN8AADLaDrxF9yu8d9pyFgnAAQCUIPgGABB1FHgLqqxcu99BVgnAAQAUJPgGAJB0GngLphXee9JRlgnAAQAUIPgGABy8jgNvqzRM9nzrSYdZJwAHAJBD8A0AOGh9CLxFkz3f13W6BeAAAHYQfAMADlaPAm/BZI/0T3uSlQJwAABbCL4BAAepZ4G3YDLwLBWAAwDYQPANADg4PQy8jYUAHADAGsE3AOCgjCzwdtLDNAnAAQBkCL4BAAdjhCve+nocAnAAAJHgGwBwEEZ6q+myx2kTgAMASATfAIADMOJnvM17nj4BOADg4Am+AQCjZnOFzgnAAQAHTfANABitgQXeFiMuCgE4AOBgCb4BAKM0wBVviz3eMx9QkQjAAQAHSfANABidgd5quij7hk83N8uBFY0AHABwcATfAIBRGeoz3j7d3Cz2fOtsYEUkAAcAHBTBNwBgNAa8ucKswnvnAywqATgA4GAIvgEAozDwXU2rBND+PtAiE4ADAA6C4BsAMHgDD7wF7yu8dzbgohOAAwBG75YsAACGbASBt/C8t1sV8+Bj+mMy4GK8SPPgSm0GAMbIyjcAYLDGEHhLXffkM7pkBRwAMFqCbwDAII0k8Ba8reEzXo+gSAXgAIBRctspADA4Iwq8LdPX3U83N8sa8uRD+uNkBMXrFlQAYFSsfAMABmVEgbfguo7AW/RqJEVsBRwAMCpWvgEAgzGywFsQVr0tasqbkCcfR5Q3VsABAKPwJ1kAAAzBCANvV59ubmp7Vtuvnz//8/bR0f+Q/ud0JPlzlh7Pz+lxzdV+AGDIrHwDAHpvhIG3oLZVb5l8Gtvqt8AKOABg0Kx8AwB6baSBt1pXva2McPVbYAUcADBoVr4BAL010sBbbTuc7si3sPptMrLqYAUcADBIdjsFAHpppIG34HmTgbfoYoRVwi6oAMAgue0UAOidEQfeZp9ubv7Xpr/k18+fF7ePjkLe/cvI8s8tqADA4Ai+AQC9MuLAW1jt9j+F57K18WW3j47+e/rjX9PXX0eWjwJwAMCgCL4BAL0Rd+v8kIwv8Bb8z59ubv69rS+Lmy+EANy/pa8/jywvBeAAgMHwzDcAoBdi4G2MK96CsFnArO0vTb8zBKcuRlplPAMOABgEK98AgF64fXT0n9Mf0xEe2stPNzf/qasv//Xz538Pq8TS/zwbYd5aAQcA9J7gGwDQuaM7dx6nPx6P8NCu2thgIU8ITgnAAQB0Q/ANAOhU3GDhzQgPLQTeenPLpwAcAEA3BN8AgM7E57yFwNvYduQMz3h73rdECcABALRP8A0A6Mzto6P/Lfm6G+eYhMDbVV8TJwAHANAuwTcAoDVhpduvnz//M/73JBnf7aa9DrytCMABALTntiwAANoQN1XIuhzZIQ4i8LYS03ox0up2mda3c2cdANAHt2QBANC0ozt3nqU/Xn66uVnG/5+mP96N5PDCMZ2mxzYfaNmcJ+MLhK4MKiAKAIyT204BgEYd3bnzIv3xXz7d3CxW/3b76GgsmywMOvAWuAUVAKBZbjsFABpzdOdOWFH1PhucSv8tBHlORnB4gw+8rbgFFQCgOVa+AQCNiIG3nz/d3Pyf2X+/fXT0f6Q/JgM/vNEE3lasgAMAaIZnvgEAtYuBt5NPNzf31v59mgz/WW8hgHO6en7dCMvuPPEMOACA+sZXsgAAqHVw8TXwdp6+7m349U8DP7xRB96CEJxKyzD85xgDcOEW1EQADgBok2e+AQC1yQTeXq7fkpn+7jgZ9i2Now+8rXgGHABAfTzzDQCoRSbwFoJTD3/9/Pmf2d/fPjr6t/THvw308A4m8LbiGXAAAPWw8g0AqCwTeAtebQlSPRjo4V2FZ9cdUuBtxQo4AIDqbLgAAFSyFngLAaq764GqeMvpLwM8vBB4u1DGNmEAANiXlW8AwN7WAm/B9ZYVYtMBHp7AW2QFHADA/gTfAIC9bAi8Bc+3/Pn9gR2ewNsaATgAgP0IvgEApW0JvM0/3dwstrxlOqDDuxB420wADgCgPME3AKCULYG34PWOt50M5PA8/yuHABwAQDmCbwBAYTsCb8Fsy3umAzk8gbeCBOAAAIoTfAMACskJvC0/3dzMt/xuMoDDE3grSQAOAKAYwTcAIFdO4C2Y7fjdpMeHFnZmvSfwth8BOACAfIJvAMBOBQJvwd93/O7Hnh5aCLyd7lixRwECcAAAuwm+AQBbFQy8BbsCWMc9PDSBtxoJwAEAbCf4BgBsVCLwFiwHdGgCbw0QgAMA2EzwDQD4TsnAWwi8zAZyaCHgdlfgrRkCcAAA3xN8AwC+UTbwNiAh4BZWvC2VcnME4AAAviX4BgD8TuCNOgjAAQD8QfANAPhC4I06CcABAHwl+AYAjDnwdvXp5uaewFs3BOAAAATfAODgjTzwdqGEuyUABwAcOsE3ADhgLQXeuthZVOCtRwTgAIBDJvgGAAeqzsBb+lknO379j5YPTeCthwTgAIBDJfgGAAeogRVvxzt+N2vx0C4E3vpLAA4AOESCbwBwYBq61XTXyrdFS4d2EYM79JgAHABwaATfAOCANPiMtx+3/eLTzc0iaT4AJ/A2IAJwAMAhEXwDgAPR8OYKJzm/nzV4aAJvAyQABwAcCsE3ADgALexqepJ+x67nvr1v4DuX6etU4G24BOAAgEMg+AYAI9dC4G3lbMfvrmv+rlXgbaaEh00ADgAYuz/JAgAYrxYDb8Hy18+f3276Rfrv/7x9dDRJ8m9PLfQ9ydfA21wJj0NaP+Zp/fg52R3AHaqzcGzhGJU0ABwmK98AYKRaDrwFeYGT1zV8h8DbSFkBBwCMlZVvADBCHQTegj/vWuGT/vsi/X0I0P11z88PnxsCb/+uhMfJCjgAYIwE3wBgZDoKvK0c//r589YVbrePjm6S/QIrq8DbfyjhcROAAwDG5pYsAIDx6DjwtnL3083NYkca36U/piU+bxV4Wyrhg6rLoR5fjvTwLuzSCwCHw8o3ABiJngTeguNtGy8EcVVT0XQKvB0oK+AAgLEQfAOAEehR4C04uX109PrXz583Bszis9+O0//8l5zPuUpf/4vA2+ESgAMAxkDwDQAGrmeBt5W81W//Pf3xb+HvtvzJ1aebm4v0M/6phA+bABwAMHSCbwAwYD0NvAVh9dv7sMpt0y9DUC38PvkagPvz2q+/BN6ULpn6IgAHAAyW4BsADFSPA28rJ79+/vx/bftl+rv/uH109P8l3wZUBN7YVl8E4ACAQRJ8A4ABGkDgLfjr7aOjf/z6+fN/2/YHawGVJ59ubv53pUvB+jI2AnAAMFK3ZAEADMtAAm8rYbOEsFvpPOeYJunfLJQuBc+BUP8vR3p4F+m5cKWUAWA8rHwDgAEZWOAtCM9z+5fbR0f/ZdfmCdt2RoUt9cUKOABgMATfAGAgBhh4W/lreO3a/RTKEoADAIZC8A0ABmDAgbeVk7znv0FZAnAAwBAIvgFAz40g8Lbyr4IJ1E0ADgDoOxsuAECPjSjwlnUvbwMG2ONcCeeJTRgAgN4RfAOAnjq6c2ea/ng3wkMrtAMq7HHOnCfjDcDdtSMwAAzTbVkAAP2UTrRn6Y+LER7acfp6d3TnzolSpuZz5mqk58yFwBsADJdnvgFAj434eVZ/Tl//lh7bf02P8T+UNDWfMyHA+y8jOSS3nALAwLntFAAGYMS307kFlabOmTfJ8IPWAm8AMAKCbwAwEAJwUOp8CavfPiZfb3MeIoE3ABgJz3wDgIEY8fOsPAOOJs6X5YDPF4E3ABgRz3wDgAHxDDgOXVjRltaT/zd93YTzIed8+ff070JQ938c0CEKvAHAyLjtFAAGyC2oHGi9/7JKMn2tVkmexl2Bd71nkv74kAzj9lOBNwAYIbedAsAAuQWVQ7Mh8Ba8yasr6bmySH+8GsAhCrwBwEhZ+QYAA2YFHAdSzzcF3lbmsa4sc97f580XBN4AYMSsfAOAAbMCjrHLCbwl8d8vc86TEJi76ukhCrwBwMhZ+QYAI2AFHCOt13mBt6yHaT253vFZk+Tr6rc+EXgDgANg5RsAjIAVcIxNycBbcBnfs+0cWaQ/rnt0iAJvAHAgBN8AYCQE4BiLPQJvq3ryIudvXvfkEAXeAOCAuO0UAEbGLagMvP7uE3jLurerjqSf/0vS7cYLAm8AcGCsfAOAkbECjqGqIfAW5K1+6/LWU4E3ADhAgm8AMEICcAxNTYG3YJpTP952dIgCbwBwoATfAGCkBOAYiliWdQTeVh7t+N2sg0MUeAOAA+aZbwAwcp4BR8/r5yrwVvdz2H5I68Zyy3eG75u2dIgCbwBw4Kx8A4CRswKOvmow8Bac7fjd+5YOUeANABB8A4BDIABH3zQceAse7PhdG6slBd4AgC/cdgoAB8QtqPSkHjYdeFvZeOtp+v2T9MfHBr9X4A0A+J2VbwBwQKyAo2stBt6C6ZbzYNHgdwq8AQDfEHwDgAMjAEdXWg68Bfd3/G7WwPcJvAEA3xF8A4ADJABH2zoIvAVt1gOBNwBgI8E3ADhQAnC0paPAW7CrDtS546nAGwCwleAbABwwATia1mHg7Us9SL+/6e8VeAMAdhJ8A4ADJwBHUzoOvK00Wf4CbwBALsE3AEAAjtr1JPDWJIE3AKAQwTcA4AsBOOqS5vV5IvAGAPCF4BsA8DsBOKqKgbfLpD+Bt2nNnyfwBgCUIvgGAHxDAI59ZQJvYyXwBgCUJvgGAHxHAI6yehx4W9b0OQJvAMBeBN8AgI0E4Ciq5yve5lv+/S8lPkPgDQDYm+AbALCVABx5BnyradGyF3gDACoRfAMAdhKAY5uBP+OtyIYQAm8AQGW3ZAEAUMSIH6Yfngl2+unmZq6Ux1cf0nK9tSX9v+W8VeANAKiFlW8AQCFWwLEyoEDsckv6pznvE3gDAGoj+AYAFCYAx8BWQG5bzbirnAXeAIBaCb4BAKUIwB2uAd56/H7Lv9/f8u8CbwBA7QTfAIDSBOAOz0Cf+TffcByhjM82/K3AGwDQCME3AGAvAnCHI82LEHQb4mYbsw3/JvAGALRK8A0A2JsA3PjFwNv5AJM+T+vnpg0XHqz9v8AbANAowTcAoBIBuPEacOAteL3heCbJtyvfBN4AgMYJvgEAlQnAjc/AA2/B9YZ/e5r5b4E3AKAVt2QBAFCXgT6Uv4hw++Lpp5ub+YGU49ADb7O0rE7XjmmS/vgY/1fgDQBojZVvAEBtrIAbvhEE3oLXG/5ttepN4A0AaJWVbwBA7ayAG2y5jSHwtkjL5+7acU3TH+8SgTcAoANWvgEAtbMCbnhGEngLXq8dVyizcGwCbwBAJ6x8AwAaYwXcYMppLIG3UC5303JZrh3be4E3AKArVr4BAI2xAq7/RhR4C56vBd7CcQm8AQCdsvINAGicFXC9LZcxBd6+edZbemxn6Y9jgTcAoGtWvgEAjbMCrl/Cc9BGFnhLNtSvpcAbANAHVr4BAK2xAq4XZfAlYJi+xrRpxHWa9w+dYQBAHwm+AQCtEoDrNO/HGHj7bpMFAIA+cdspANAqt6B2Y6SBt+ChwBsA0GeCbwBA6wTg2jXiwFvY3XTmjAIA+sxtpwBAZ9yC2koejzXw5jlvAMAgWPkGAHTGCrhmjTjwNh9pvQEARkjwDQDo1AEE4CYdpuFFMr7A2yL5uqrQc94AgEEQfAMAOjfyANybuAKtVel3hsDb+cjyMwTcbLAAAAzKn2QBANAHv37+PL99dPRz+p9nIzu0v4ZXenxv2/rCozt3Qh6+HFk+9uY5egAAZQi+AQC9MeIA3El6XH9Pj+/fm/6izHPe/jyi/BN4AwAGy22nAECvjPgW1MuWbj8Nu8cejyjfBN4AgEETfAMAemekAbgQEHvR5BfE203HtGpQ4A0AGDy3nQIAvTTSW1DD7afv02Nb1P3BcVXdm2Q8q94E3gCAUbDyDQDorZGugHva0Oc+Tl+TkeSRwBsAMBq3ZAEA0HdHd+6cJ1+fZTYWIbA0qzF/wmq3j8k4Vr0JvAEAo2LlGwDQeyNcAVf36rew6k3gDQCgh6x8AwAGY2Qr4O5+urlZ1JQvYdXbZOD5IfAGAIySlW8AwGCMbAXcozo+JO5wOhl4Xgi8AQCjJfgGAAzKiAJwde3i+tPA80HgDQAYNbedAgCDNJJbUCttvBA3WvhlwMcv8AYAjJ6VbwDAII1kBdyDiu8/G/jxC7wBAKMn+AYADNYIAnDTiu+/P+BjvxB4AwAOgdtOAYDBG/gtqD98urlZ7nncQ93l9CIGTgEARs/KNwBg8Aa+Am66z5uO7tyZJAJvAAC9J/gGAIzCgANwJ3u+bzLAYxV4AwAOjuAbADAaAw3A/bjn+6YDO06BNwDgIAm+AQCjMsAA3PGe7/vbgI5R4A0AOFiCbwDA6AwsADf2204F3gCAgyb4BgCM0oACcMcjLgaBNwDg4Am+AQCjNfBdUPOc9Dx9Am8AAIngGwAwciMOwPV5xZzAGwBAJPgGAIzeyFfA9Y3AGwBAhuAbAHAQBOBaIfAGALBG8A0AOBgCcI0SeAMA2EDwDQA4KCMKwM16lBaBNwCALQTfAICD07MA3HLg2SnwBgCwg+AbAHCQehSAm+/5vkUP0v5S4A0AYDfBNwDgYPUkALfY830/d5zuqzT/nqhFAAC7Cb4BAAetBwG4fYNo8w7THAJvNq4AAChA8A0AOHgdB+Bme76vq+CbwBsAQAm3ZAEAwFdHd+6cpz8u2/zOTzc3tyqk95f0x3GLyRV4AwAoyco3AICogxVwVVevzVpMq8AbAMAeBN8AADJaDsC97fj9RQm8AQDsSfANAGBNiwG464rvn7WQRoE3AIAKBN8AADZoIQC3SL9jXjGNi6TZAJzAGwBARYJvAABbNByAe1XT57xuKH0CbwAANbDbKQBAjoZ2Qf3h083Nsoa0hd1OPyb17noq8AYAUBMr3wAAcjSwAu6qjsBbTFv4nKua0ybwBgBQEyvfAAAKqnEF3N34vLa60jVJvq5+q0rgDQCgZn+SBQAAxfz6+fP89tHRz+l/nlX4mBDgel1zupZpusJtp/9SMV0CbwAANbPyDQCgpAor4MItovfqXPWWSVOVZ78JvAEANMTKNwCAkiqsgPtPn25urhtK0z/TNN2k//mvJd8q8AYA0CAr3wAA9lRyBdz8083NvRbS9CH9cVI0TenrtK7NHwAA+J7dTgEA9lRyF9S2VpcV/R6BNwCAFrjtFACggoK3oD5p6nbTDen5jzQ9/0h2334q8AYAAADAcIRbUNPXbxtelx2l53JLej7EzRkAAAAAYDg2BOA6C3SF743fL/AGAAAAwDhkAnCdB7rWAnACbwAAAAAM39GdO2d9CXSl6ThJX28E3gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgHrckgUAAMDK0Z075+mPB+nrOPPPbz/d3LyUOwBQnuAbAAAQgm4h2PYmfU23/Mk8fZ1+urlZyi0AKO62LAAAAFKXyfbAW3CSvt7JJgAo50+yAAAADtvRnTshsFbkttK/3j46+vnXz5/ncg0AirHyDQAAOCvxtw9kFwBDEx6vkL4u09eH9PUxfb1JX2etfLfsBwAASjiWBQAMSXyuaXh0wknmnyfp6yz93cWnm5urRr9fEQBA7wcLYZDwournpIOKU7kJAMABepx8G3jLepGOt6+b3FBI8A0A+i9cqZvKBqBBixJ/63lvAAzN/ZyxdgjMzZr6cs98AwAArtNX0Sv+r2QXABQn+AYAAAcu3mrzpMCfPk//diHHAKA4wTcAACCJD5u+SDavgPsSnEv/5pmcAoByPPMNAAD4IgTgwkOn0/88S77uAhcs0lejD6IGgDETfAMAAH4Xg2xXcgIA6uG2UwAAAABoiOAbAAAAADRE8A0AAAAAGiL4BgAAAAANEXwDAAAAgIYIvgEAAABAQwTfAAAAAKAhgm8AAAAA0JAjWQAA0MKg686d4/THSXwdb/mzZfqap6/Fp5ubxUjzYZrJg7+lr8na8f89/vcqH+ZqT6m8XR5ynqV5sDrHJhvqVzinfo4/513lU5rGSUzXrrYgmB1SeWbayGn8p23lt8qbMbeTk8yxn2TaxKSL445ty8o0lsUqDeFcWo64DIr02WPNg/Vxy64+e9TnZB1uyQIAGMSE+l3Vz0kHRPr99getZ+nrfpysTEp+xDIOZt+mr+uuBvbpcYRjeJFJfxhYP0/Tc1ViAhM+46fMJLKX+RDT+jR9ne9zrB3WtWfpj0eZCWJI90Wa7lmFNudFprzC571KP+9lg+n/aa2OFf6+WEcfxHp2XOKrw/e8Tr/nWQuT+GxbcLzHx4SyfB/PgXmP6t7jWPcm+9S9GCz9KebLvu3DdSZvlh3nx3StLr8tUo/X6shZiXZxddyLGo9hn76rF/1VTcf9YM/zdLHKg/T4rzs8jk199pOiaarpnOxlXUiP7V3yR3B/k9N9+80ibg3gBMgW+KgiqWtXNJJMRcgW+Cij6PS+bmav8Kz+e1Uvl1Yh7NWOtdJ+rZXdNPnjipyyG3D970PwbS1fkiYHJyOoQ6vJ13nNH30VAxLzFo8lDOLfbPn1w12D+ZgPT3MGuvu4jvkwq/lYw5jsw5YJ12lf63ya7lDPLrf8+l7Z+pLT3jypOwAXgzcvtvz6YlfgMx7706R8YHvdPJbxssbjWk3kH+05gc2b5L9OXy+7nCfklN3OcyaWXd15swrEPe9izrjjXAzzuXs7zrdHSbGAW6PtYubiQ9kgdq/KYc8+u44y6DwPcvqDLs7JTsYuO46xv8G3WBGrDpgWRa4WrkX7T3I60d+Xd6av911Glks2ZtPM8ZWt1LPV8Yb/bqKjjVcdK59cVRuYeOJPakjLouqV6lhu513nSUvBhtWKhKLn/DzWy0LnYE3lOivTINZUfkmZK+Jxorq6Upg9z583cWV9x/cVKbvXRTrCmtqGsmVXR/9TqOxi/c/mY+31v6aBYSvBtzhhzPZX0wJ5ke2fej/QbrgtfZHUH2zaNCa4aCmg/2FH2xL62btb6uvTlvLheV0D5TTdlzv6jFC3T3ta7z7u6F/DqoOHJT/vzY5JaLgA8UOL6d8YtIh17LKm8WJ2vHZRw/GENnS1Guy4hSpwlXQXbPplxzFurHsbVuWMIl9iuX/ckR/fBJLjGPVFzQGf1XE/KTNXjGl/kdR/waix8W+NY6s2+qrW6mLPz8lGxy4bVoC35Tqec7nHdavAATytYcJ1mjMhrxph7WV0PTZk58n+t1nkFfLbOm+DyBn8tNbA5jQatU80c9Ky64peobpZ9yC15vr5OPl2aXyVc/BVsuMKbIErDbXXr7YCFgWvFNY2+MgEFesou0Usu6sdZfdb24OvmvqfnWVX44qJZfLHVb2mBhSN1+Uar/yGwdXrvt+m10B7+jS2qW163sLtcr8VrVMd5sPLmBfLisfa6RXxPdMc2rHLfcfhe7b59+pcwdCjOlY5wBonsZcdTP6WsQ961mLdy+uXvhkDx7HLZQuBjk6CPzmrhL8JfLRQT5YxyHHdkzo7j+npxd0XsR25TOoPfOaVyfOmbt2PxxXiDR9Ktqdt50Mj52Rd84aK86l7eeOQ2x1W+vMY7AkFXjUwtQpyfQxXLWPj3uUJPYlXTz8m3z4vo05fGsoQqAqVLZ48lQcdNXzGjzUEFY5rLItpl8dTU57W3uHEBupjTYGH1Tn4NJ6Dz5IDEfPyRczL86YH2w2V3SS2Ux/jJO4Qyu0s0//UVf8fZ/qg44HlxzQGHd7VNACbxv7pYw1t8BDybzXYfdzB1z8NK9O6Hvf0IB/Cd36IaWjSox5WwZ8KTPjqdtxRHTuO7dTjHrYDx7EdfdNR/hxn2oOTnmTLcbbfje1DF33CKl+aLpeTIvkRx41N15Pw2W/yxnVxvtpGnQ15864PdTOOSz4m7QecvqwuDCuLG6yLxwPIh6bGLl33z5MieXm7gwp/Em9hqHup+Mp5HIA97uDYshPjxifiG4IeVY/5bQsdT5FJW52mNZxIVbzv2yQ7Dn6eNlQ/+zj4a7rzftzS950lfwTdmmpLQsDk3dCCRyXb6DdxoNlUsOI8tsdnA8mPF3Ey28SEaBIH229GXKfOY/5NOkzGSdJO4Cmvfeo6H1b1rUpdfp3z+7M+BDrX+qG84307knNtFXhrsp6/3TNtJ7F/nvYgq1ZBjvOetZNdBSWz+fKx67FpDHa1OUe93HZRPOc2+6bGme867qsex3aky7p41oN8OO9BPtQ9dunDODN3fHC75YI+a6HjXGX+izZXIKwFNbqwOuZ3FQaGszoqXcU8v19zvlRduVZ1INWb5xHGzretyVFvrnA1nJdttS9tXCXN1vmPYyu72C7WtbKrSHv8ps+r4GL5trWC5GyM7UHmdr99y3gR+93sazG0SU1PJtbr+bDXeR5vlc4rg6c9qoZ5V/oXY7j9u6XA29U+t4PF+v+hhvq/rKEdyJ4Hl324E6HAbdFdtA9d9UVhfHXewfc+XQ/GdhB460NfFY65yqOE6uyzT5Ju++wxnpN92KAytz4cjbygw3eGlXanDW9LX/W5YHU37CGKfFH2IeAhj9L3zWsY3Jwk+wfypg3kR5XJaaUTsC/PIOyokz2OdfF0TLsitpmXLU04dnWGp2PYHTVnB8PB90F7tm1tX/E8GVmd2mdME447rKya57WJsYxC/1XmmbFdnbdl8mEVYHgf8+O73YPjxczVLtFlNkH5Jk3p5yz2zIfnOccUHpvS+TOGMxuV5R3LGBR9hMvqGdB/j/VrvqntzexC/vu5uU8bXWFus4jpfB+/e7FjDLBqCx7sMRYIQZe/1bGJREvtwyq4sSq/b8bRmfxY/dwnT1bt5N0+9csbrNrJJDOnWrWF+7SLoU0MdW0eL+iWGccuM+Wy2vRwVQZ/Scpt+LUqg8s2x0Z7jt3DMYfVsLO8viSzCrlMneyqLlY5J7/ps2s+J+9V7Fevkm4fSbDqf3bXxR4PUusc8Icrsqc9OpnbmDi/iQG4q5LvfZvUc+vobI+8DOme1J0XYRKz5wC8aj7M+lAZcnaqa0Ooi73cIa7P53uHgbfvBgUDL7PjpNtVOdmg07IH+dFF4G1ok568PDwrOaYJ/XCpYE3ss8LrZWZDl/OCefwmDmL7lMchD94WuSiYCUxeZ87hkOdlNueqUteuY7Bn1zkSyuJZx3matwJvOaJNT/Lqfqgzr4pedI51YlaxHdhnbnMV0zkvmc7wepbZbKnMbn4hWPxzX3ebLJMva+V2ncmTVfswKdM+pK97PcuH0EeEgPn1lnZrtja2OUvKPf83BLyelwhQ5J1X15n0lK2bJzHtT1qKQ5QZu79MSm6gFfut1Xm6OrazonWxbxdpK56Tx5m6UOacfFMlH9L3PUnfv+ov2h7jhjwotMNwG7edTpLuV4VNY5R/sBPxPV3u8cyHWQ3fu++tntOmyr/l41jp/DkrsY52favXcdKf5c1V8vJZy+f7u56U3ZuBF10fzoFVAO64J/lx3HGdejfgdmBSoj0Lg9YQBLuocjU3vDeuXLkXP7PIuKsv520YjN+NeXC95/F/CSKlr3D8D5Pit/ns1ffEwfOrnD971OX5nJnc7PIqGb9wPoTJ2um+9WvP/D8pObfJngfzim1BGIvcTcqtanza0w2VrqrmS8yTl+kr5EkI5BSduJ/0aIOwZZy4341t3bLAca+C6/dK1IWTgn3Doux5lamb90rMJR83fdtl/PzLkufpk4p99jzuantasL9aBevGck4uM+fkRZlzsmo+xLL7Iezouu1VoH6e7nr/llfhOw7aCr71YcLxuM5d1wYQePt9olWmw42R+6qR930b0vsN5cH9lo9jZdZlwXcQLMrLy2kyUHGly9MWv68PAaOVwZZbdNajc+CyJ+noPA0D3hW56CrKsNLtXp23f8YB/b04OM49b7vYeGptMvkwTEDqvD0zTgSL5sGX83/P57+9zBkLrXY47mxMWyD/XybjtjrHWh1rlVxN3dR5sMwE4Yq2MS969NzNRZzgXtScLy9jnhStE097kCerizQvK9aFum4tvo7pme2ZnhCEOy3RRr9o4Vwt4kkD5+ks9ldFApiPO94dvqlz8iqek0UvjnSdD427nRyWy5pO5sfJMAJvvx93yc6l6kBm300XmjrZ9u1Yq6Rn3uXy4dhwPU3oVdtRsOzOB9a+UNxZxwGRPnnap10jC56bzwr2JxdN3uIVV8FdFMzjLi5+rlYjXTd0/MsSebDX5K7g6refOqqHoUzzNlq4GvKt3V2fYwXGA5OC58G9JlfkxUBH0WB0X+5CWOXLrMH2oRfBnxJt5aKG475KqgfgrmIAallDei6S4heKmhoLFLkldxUgf9lgfXxYMC8uR3xOPixxTo56/npowbdJ1avteyw174sytzy9r+H7Tlp6T9Fyn+xRzlXMuiroWM6XCXVqa1fTyUDbF0oMBocWdGoyL4aS0IIBj1VQ4Krp9MTvyJssHHeQx6vJ5LylPCgy2ZzsecvdVUOfW9VZgT5pzLecXnT1LLt4YfOsxHmwaCNdJQIdXa86XuXLskd5Mu1opc2i7ryI58W+m6zM696YI35ekfnQ0wbO1TCPK3Kx82Ebt6wXrI+TDs5P52TLDi34FlS9UjnU5x8dl5jU19EIlTppWjjJyn5+1eBbl897K/PwVfol7yHfDJ/g+B/OBxSILHJuPm8zKBCebVKgv37cYh6HwftFmyuuCgYh95rcxcDJVd2fW1Mfv8tVX3Zab8DzjjeRKNJ2tzaZ3XNi+6ijdrf1fIl5ct1E+1CDRtrKuCK07MWPL6u/mjrOJP9xRk08HuRFwTKYtVwf5wXOz7bmAQvnZPsOMfi295XKGI0eclDjvEiQKw7aqg7cym5WMG342O83nP71PJx1UcBxQOW2tgEqcUWd4ZuO/ZkWJTwawLlZ5OH2s45ugysysTlvKy1trHjb0N8+KTChmez57LfnDX3uvnXxvMA49PlI24pFlzt2Fsz7ZdJB4G1tYps3/uxiReyqfegiX4q0kdOWA5JXDc8Tyu4g+qqpgH383LyVuMc1P5e9yHOmrzoK5D9M8p8neuacbP2cbM0hBt+CB3sOvpuaJMxjZxkGTFfxvxcNfVfRDrdqp1B25dj9hst82nD6s647rNue8zZcyk55H6LzAaSxyMPtL7pIWBw450202ghwztrcbXLPyeaDPfJ3keSvJmozgPyoQDksRtpWdB1ULNJmP+zBs/byJvdf2t2WJ7YvuwjMZ9rIInXnbCx1OQb2iuZ3G5uzXBX4m2mN3/eowDE/6ag+hvb5VcX011ImXS0UKThuabtvbU0fgm+z2AhlXy+TZp+ZdbbHks4w+K5zGegiDtZ/iLs1hStlz+IuI6dxe957Sf6OW2UVXXFR9blvZTddmDZcz8o+961Ket53cSIVXJ1Rh2U8P2dJc0HigxLr5rTlslvK+U7zpo+r3+axz1nvk5vsj48HsAow73EVr7oMeMSr94ucPG56YtlpYCROIvLq6b558KoP53L8jpM+l0ODFl3ebhrPn7wxZGeT2Q0T2yL14LzFZL3qOE9eFhivtrWBynVL/cXrEulZNpz/4XjzLs7cr+lcLTIXetJxkDxvbn/SQnC86z77qsA52fex4V66Cr6tOoYfMkGn7OtJ3Knmbvy7Jk6QackTuc7oazi+u6Hi7Tr5w1WieDtFmS16iyhyLHV830nB/G1rm++20tPV4KvJgVQ4plWweHXeroLEPyRfr7R2NjAegSav7lzF8lkvux9i2V0k3a7W7NJ1Tt40Xa9/6kEerPrju/FC0JMNffJppq502h93MOk+yZl0t7FqoI6B9IMGv3vRh6BDgcnm8T79e1yxk3d8bVyhz1t5NetJOTTVVncpr63ubCXNljp7iMGmqnXopKVnbb3t2TnTVnryFibUNQ7Iu8iy6Pi5kUV30z47gHPyVU/OyVZ1EXybxUH+s7yoc9xC+1nydQVY3cuV75c8keso/NWzIF6WPUlLbtGbezx5EfVYNlXzfFrz37VV5lWCb4uultY3NPgP5+tqZebGYHGsn9fxWSN1B4oPxXmDbe1FLJ9tZXcV25d7SYe79HbQD4V6/TAnb5qu12cdDyxWD8B+ljcQW9WVhvLifo/rSt4E9boHt5mtJlrLjvrZXrT5BSdU++bD8wLn8qSpYyu4OnrMO5y+7+qLYxudNxF+1ZN2oEydnbS06vhtT/KjyEqwNhYDtDLOin36si/pKfI9NY2H8i409aWdvKp4HINsT/cYO0yTkWk7+HYdJ/GlOqjYgJwm9QbgTmo8kYt6UuWqZIkdQgpN+lpokItuWtDWxKvoCVxlAN1J8KLA6ox9vIzn67zMuRoDOb25Atx38XaWugMwT2LZLUqU3TyucHo58izvU70+7nBgsQq8lepXG7gY1PfB1SACHnFcdZ0z0Z409PXve1ReeX3wj3vm76zAZzf5HMe8z150/My9NtqrvrYBRSbSXbQJIU15Y4AHPTgn28qPedKD29xaXnGUd94s2goaFxxrnLRwvvblYtEip3ymB3BOLgqckyfJyLQZfAuZe1GhgFbbINfVSBSq1AWveBVR164qdd32U6TDrXq1alJnWdSg6PLVKsHAriYhdefh83jL877n68ukoweQdzQpCMcb8ut0x+uqgfq2sY0ou7p2reyeJOMNnj7pYb1+0EE+fOlPKw66i+wwWVgfd7WK/cVJzsRl3qMk5/U/Jw3Wp6HkQZV6lhdobeQh9vEzz/P67DF3sh3fIpXXR1/3eJOLvEDDdORlt2m8tsvfGv7+Wc+Ot+2yabSviAsRds3z5j2rj29zjmfa0DnZp3FL3jnxYzIybQbfKj/cMJ4wbQ8w6qr4z2s6YZZJPVfYpgW+q2onkTvQj4PK456V5xB3Oq1zAn8db/euWldDPR3rKqpNz8kKK6pmO16LFga/L+sI8scg09hWUVxVCUqu1es6+6FpB3lReYOAErtVFTXpYZ3J6wtmPUvvrOLx7FsX+pQP86byIK4syztvzhs4przP7PwZRiOX10a/7XHa8261HOUzlXb4+wD7oSr+0bP0NB30ORnYuTo7sPq4yc85v/fMtz3VuRz+Kqkpcl4wolzHqpSrmiPtr1s8/uuGv6PtiedJTnonFU70eYfP/KhrUhXSX9vKnrjKaJGMSxg83C3ynKyWyy6kpc6gUFMP1+9CrYGiGJyuaxA56WDV18ua8mFWYz70cYCV1z/16XbLIitMRncFecu53mQ9y2tjH9UZzCi44dfrhC7HV7O+JrzFW/2GNH5jvCYDO1fnFY9nDGaHlgdtBd9qGxgUeK5J251uEbVG2mtcLlrk2N43/B37Bjev9nzf/QbLu5NGvebVg008NHhMt8PM4kq3Ni8AFM7nOsuu4G5MQ9HEtvJDXfVV9wYBdfXvQ5wALgY2kD2EFS6NTq4LPEcr5PHjGr/ycU659WW33VEqsDvusse3nBYdmx5S8G0pL0Ytb47Xq+BrHIvtqpN/U6TjC74d9aThLysEhM5bSvu0h8e/GvRXrZB/ayHtPzaQv7MKdSDv+04q1suhN0y1D+LDZCUdwD4dQQO6eu5knWpb9dbQbUehPjwa+KS9kQs2YdVXWq8XNdXradJe8L7udmqWjFfeQP5dWgcMjXs2mWmhTMIFpcsdvw875D6r6bvydtvt4y6bY5LX9w1hJdU8Z+x7rJjlxYH4ZWB99kSRjU8rK98aeB5IK51djbcChZP9tzpfNZ2QJwXKrsjuQHt9R7ydYp/jeF+lDuSsNrpfoZ539YysaU2fc93gIH4Mzw9rYvXUcZ/zt4OVxo3UvQHU67+0PBGrs464jWc4rOqop85fJbtXK4Rbyc9rGIOeFxgjWfXWrLw+ejGAY8h77tdfFDP6OGjH7SEmusXB/kQV+WLWUEM43Tc9sQ7sO6GeNtBwz0ZQzu8H+tltaCoI9aOyG3S9ruuRAm0OGJvoPxcJYwgkUFzeLflPa/iOvM+4suqt88n8zwM4hkXFYwR9HNSkjeDbTDb31qSNyeuOlWZ7rTLLrKTct27d35LOSYWGu8sddOp6JsBcO7A9/Q1Nco4HUHaLgZddY3nTs10ei6Z5qY4cLIGa+rxM8le/nVUcN+WN0Z4rBrTPAMNxWxbsNHF8X1Rd8bPtqtp0j8/KTnb3DQpOS6azbLoGWU+bDCSM4Or83/ucuCYf+DzEANNa+t0WCd33U6NScEOaRxW+osiqt4WSABgtbfwICb7tNpEFvw8yq0xgt91at0+w630dE4ktO1jtG3xbmuCPvhMxaUXdYMhCP26lVL3ynrc23WdH6zg+yXvfa9mPuQzosxmWI1lAiQnmvsGpkw2Dy2mFdHwRAl7p54TGaZ9b98L3rwfM9t1s4Vr1KGRhENgIgV/orl8cStv73EqpesWdVa+S3TuvP9qjnuStmJsNfUXywMYtuwxhs4JJxWOEodg1J6y6kKTtcf1zz/QcJ8E3jVRR4Zlmj/f8nk1Bu+meg93ZhsnPPs9VCYG2lwXSWcR7VamWAWDfO8K+8rDkbnnA74FK+6NTuXDwwsqE8x2/PwvPky0a+IzPnj0v8J20I6/cxtD//qyYGYn5jvnlUp9NH7jttFqnO4ZGqugkY1blizasdNtnldmmNNTy3LeKmy3MxlAZ0jxoOogwGfAk29Unxjz5YrP3OW2msj9wMah2lfNnZXY+zVv1NrfqrVeGMK65r5jAnTf0g+DbbgtZ8I0qt1euT1KmNU2E9h2EHq9NnPZtlBc9uJWnrlVZjU0kWwjsHbQYPG7qs6cDzxv1mn3lBd0N5gnyVqKdF2mjY3tynvNnr2R3ewoEOidN9r8tje1mSpqRyLtgNpVFdD4vkQWt6GvHVjZoExq1sz2/68caJsOzDQOj8Ny3fY9/msmDfRvkPjzv7R81DtCaqqs6vM0WNebvVUNpHHqA4SRp7rZh9Xrc8urN/cQzPw9euACXjkNmOe3Befp6lvNR4dEeuwL64WLflRzvpB046aj/rTbJ+zrePi5wfHAIY+om5zlQrF2WBc13SCO6x7xKg3VSdcK64wrkbM/P/HHLf5fRh+e91XVL5Kbn4CU1fjbf+7nG/G1q8P9g4HncZN7UVa89N3KYY4BwMeqJbCL5uvpt1zjk0dGdOy9zHmHwqMB30E07cJLTR171NO0/5fx+4bEaHFCf/VOD8xwoxG2nO9TVIQ1gSXrR/AiN2mLPt59UnLDOGpi4Trekr6509aWzKeqswbp6lrBx4Ftj2dV+C2T8zKGX3VmDt4ee1/Q5Jj/9HQPsal8nbmMh1pVZznggtEGPd7S158nuFUqhLlpl2Y28MeZZjx9BkNd/zxQvI2qH5znjqZOxzMkZLsG3fHV0TFP58c299vvkx/sG0vTlWR1x0LRPYzzryRXDOm8ZOK87cXFSobPbbFHT5+yc2FXweAR53EgAscBkuatzmHq9zfn9T7KI6HmFupK3KcMrK5Q6UyTo2bu+Mu2jzgqMvd4qXg7sfD2XReTFB5r8cMG3diZFD0aUH1VujzqpsKvobNsvKu78NU32X/XWi1vF4oB8UdPHParzqlAMbD5NaKLubiq745rL7tFIsvpFA3lTZ70WfBvwQN6VdDLt+a6+eBKD9uvtSV6QJPTxbpXqdoyV1w486uHqt7z+e5kem9WUjM3bAZ6r9EujYzrPfMsXAixVr2h9uZ2vjl0xa7zFZd9dOkNHfbnnd/6Y7Hl7VYEgRfj9Pnlzv8JJ1qdBy7ymxuI4lm9dzyl8mlj1ljRUd7eV3cOa0nWZ1Leyq2t1582LGuv13IqWXk+8w6Y+ec98elFj3WLYnueMkUKfeLU+Gcz5zCttRC8m9Gc5fUwo2148AzIGefPGFQJvjLHPvk7r/3LH+HV1p8gzuXWwFjm//7HJL7fyrdjEuK7JWtXONHSk72p6ne/ZqOU9A2eXMHm531AZvK+Qpn1OsmV8tkCfBoZ1maZ17bKG+nqejOO2xabVuYLyrKaye5aM7zl9Z/G4qubN46Te2xZmToHee1Wgbk1lE3E30l0D+0lc6ZYd100r1j/aKde8AOjjuLtop+KqniJzDvWKQ+2zn/bhXKUzeZvdNTqeE3zL73Dresjt2abbDRroTIuqckz7ThZPkvqf91ZHmk5azIOm1J2ecCvV5b5Ls2OA4lIL0vi5uLXsKrQ1oZ0Z663CT+PxVcmbFzWnyU6n45h4v3ErC1Hes9+yK93ynhl4VcddE7Qyoe9LO1Bk1fqsZxeQoU5XRc4TffbBypszH1eJ2eQRfCumrlVFl9krniWFCV9dUfpFxU63Sn5MGjhJqj47a9JhnahrchgG53UPpELD867Mio64gcW7pP4AxZgn9lV2Ed5admk5fChZdmHF44dk/KsVH++RNyexXtedN565Mxx5AZXj2F4azGvTw8RvV7B2GtvbSZK/iva5HO2NlwX66lCmb7pKYIlV608UJyNugxcF2s4wp7ZI4DDrR5GYQWPPvBZ8q2cgVcabMrc+xWDGh6Te25xet1Bp2z5JgjbTNethVW3iFoKTOKEMr40PFg+TzRBUTl9hwPkxGdfuvm153ULZHW8pu/MYWHqX1Bfg77uyefOhoXp9peoPZhxQZOK9qledBOAyAR363x+HgX3eCuOZVW+9agOWSbFgaC2P7tjj/D9Piq1av7LqjQPwssDc/ayLc3Wtz3bBrht5F75P4l1ctRN86yawEW59+hiCcNvuOY8n5GUMZtQ5Ia5r16y2VmvMSvxtW4OJRU8HxNdJfUHi7waTydcrRKHe/haDFuH1S/pv4RUCb2eaib1dNfjZq7L7JZRXpux+i2V3mRxuwLTrvPHMnWG5KPA3rQfg4lgi1Nd3sY1+53k2vZ/4nRXoM61665l4Mb7IuHS1+vy4pTbgRVJsFU+ok1a9cQjn6rJgn13pMTt7nKvH8ft+i332auwpCNeuInewvWhiLCX4Vt9AqqxJ8vUK1YcYzPgQT76PmRPyvInJXk27ZrX1nKL3PUzTrI8VNJZrW5P5aXzpLOopu0XSziqo40zZ0W3eXFvVMrjzdJYUu3h1Evv2RutSZmX807W2OHyvZ9D1vz/eVT6ztu8yoLCHBecDjbcDcSJf5pEID+2cywG1w2FRQpHFImG+3fhFq/j5m+b3X/psJdZq3QhzriJj8Hd1t+GCb+UGUk1ehVxtRjBp8DvqWvX2ZWDYUtbPepimtz2uqnUHiWmPVQ7Km/6PBcKqkSKrrCdx0Pai7iBYnHA/S77eDn2y4/utRh5uf/xa9vV6PvCw4J+v2oHLBtqBEHAr86iP5wK6HKCw+m1RcB7+Ia4k76LPnto1vZfj8NXzfGurF4Jv5Trcl0l7tzY2UsnquuLV0EPiN33PrMTfLlsqn1mP62ibq9+ot+wWSX3BcfrNM3eG7bRE//dlghwHbpOKA/hJHMCHCff6ardtE3+67Y/3eUTHIl6Vp79lO0uK3dK2ch7bgRdV2oHMs0hDG/AiKX73Qehznik5DrQdLrpaNUn+uCutcrAlbtb1ItNn5/G4iHbrxlWJuMHTTBt+VqVuCL6Vd5EMc2XRdQwe1mnWcJpnPUzTvO9L9uMAy8R+mJ4nVi6OnWfuHN5g/jgzcAu3gz4uentLfP7rs3h7adGg28pCafWiTW/jPXQzcSsTgAvn7SoYv5rcTwtO4M/jplarZ5FOSnxvCLxdKDEO+FwNc6LTEn32JPa1v8Q++7xkn/0i9tkf4jlftM+eKa3WlYnrrNrwN7Fu/Lbh9SbvAsuRPC9/AqeZ+iQZ1vbEi5IDhKLCM9bOG0z3+z3f87jBNL0dUGPywRk7vEl92r6ESf07uTHejt4zd0YzFjiNg7AyE+HfH7Sfvj/8mG8Z+IVBXpWr4HOrp3pRTxZpOV+VGCtZ9Tas8r2K53HZOcFJfD2N799058Ykqb56VeANvu2z3yXlnlddtM+uer7O3BHRWb2oM64T6koIwN7dNta38m3PzjYZzu1hX67QNzTZa3rH01lL7+nT59fWmCTNBFxpvuxmidtPx+plfAAwIxm0pT/uJdVWGq+e97r+qhJ4C23IqRLqjTIr2TzrbZhzgjIrYTc53tAGTKrWO4E3+K7PPm2oz65yvq7aELprw+tccR7a8/NtvxR827+gniTt7E5YRRgInDYVSW/6GWv7PBi24TQth/Sw2tiY9KWOzhLLqYfavgy93PqS/lksV8Z1roZ+4V7Sj1sFv9zSnKbn1OrKXtWRRVLsYmWdm2LRbhmH8q0aiK977P9MycB35+oqAHfVk3M1LJBxR0T39SK0l3VerHiw7ReCb9UK6qLHA6VGA28tTGyrfO58YMfadB3tuoMJEw9XdPYru7myq+xhD/Jx7hw4iIHbaYd1LbTz9xp4tiv1KLIR0qsBTcBMFL9vAxYxEP+kw/wJ5/9du5rCznN1GcfYZTZPaqLPvtvA3RBDa5uXPaoXV0n1Vcy5BN+qF1ToZPu2CcM8DsLbmAS87eHnvm8oTe8HWke7DMA1edvzIbQv95Rd9UFWG53pDmFgZSXSYZyvs3jOXrQ4oL+K9esirrBqwmJgA/3epTcGQ2YFyrIvdqV12cD4crHn7/rYDnwJgCXtXpy/jhP5Jy33NfMK9air83CZk49NnTdd1OVFxfJrYlzZtz47nKttbnZ2Fc/VRla7xbZ52aMyH1R6YzD0bg1twdaYgeBbPQX1ZfDbkwodnil0r8FB+KaOrO2BX5PvHcwgomQ5XSTtPwNunrSz+nLs7ctF0v4tbaMqu9ge3u2gjQ7tseDzAY4J4oD+oqF+YxHbhNUAvum+adft0q96WARP9vxdp+lqa9xW0POWy/z1nr/raxuwjBfnf4h52UTZLjMT+Ydd1J/Yt70cWPvwqsH05gUS2q7L1znpaXsTuV3H39mjfcLK9fT1Q+yzmxgnLmL7/0PDF8qK1OPnAzsnn3dQH0JdDBft9709eWe7KPhWX0HNM8996WKiNYuT5S4GlrUvma0y6Y+NWt0N22LogYgYJG7rmSSr1T4CbzUNDJL2lsePsuziJOE0aWc1wqLD9pgetbnh+WvJ18DvkwITobxJXRhfhItrd+NkYdHScVwn36/wD//9vI/PldqR3idd7iSaedbQYkO6XvYsD8OY8uGGtDZS5vEznw+ljpWcxD2Lwfh7sf+p0rcu4mQwBNvamsjnHeOTLWV30ccNhrbUtUXM01lN44xN7fzLtoNLOem56CA911uCKat09qHPvpfps6vkzyx+xqrPftnWhdgd7ekQz8nrDtM1iwsgVoHZ6wLzsOtY5lvL+taudx/duRMy42nFtM/i4LNWadp+q+FjTptoeNK0hV0uHqevR0m57Yz3HZC/6nJAmR5vONYXdU7+Y8S5SprClsHnNaZpVNu1xzJ72kD9XMSJxPWG7wzbe08rfn6pgXj6neH73tXQAN/qSbk12bbsKrs62tuyZVdH/7Ox7GK9CG3EpOY8DJ3tqzjIXtZc9r2ty12c2wNvfyex7q3y7C/Jt7ubhn79H/GcXPTp+U0x7cdDCc73Nb1Dyse205p+30lsq+YjbwemsR1Y9UM/rvXr7zP9SsiLed9XUceyW/ZsFWfr6Y1jtWls15dxXrPo8DhDes5iXetDeiYxPcexn7vuc92O9WSS6af/tjZ+fJ8ZR/etzx5UezqUNiSeUydr4+tC5X6UULvYgIRJxLO0cM6TrztenNU8wQsT5Nc9OcHrTsP7mj7jvGdp6lMdfZnWzatYL5/WEIRYxMnzlRag+bYlLbtw9TwE4X6qoew6D+B3kI+hzbob2+dH6x3onvU/3E7x0i2mFKh/i1hnZgNNu/QeUD62ndZDWTE/xk0RhlZ2TaU3jgOuk/rvDKqSnqse5XtoU14OrJ7M+1KezsnenFN7teF5wbc6OoamOu3nPU5btnBCY3eVuQpyP070piU+ZnXVKwSAZn3rsMOJkh5fnfdk19G4zZJ67xMfXINbojO+ilcazmL9nJbI41Anr3vcWC6Sfj7foI6ye5Z8DcSFsvupZLtStuye13RO9i0fV/V/Euv/g5J5GPLudUv1v891+XVS/QLF6CaiAACwcksWdGfTksUNk0MTErqom5Nk+4qqxT5XwtPP/JhUX6V1MLemVSi70KYc11l2HR1HKOdGbjutWP+XnmUIAACUmmPIgu5UWbIIDdfNRVL/ytCJnG2l7ASG+ln/AQCAA2W3U6BxcZUnAAAAHBzBN6ANJzV9zkxWAgAAMCSCb0AbHsgCAAAADpFnvsFYTuZ6HlAfdr982EDyzur4EBuQAAAAMDRWvgFZZ3U/ny39vGlSz2YLC8UDAADA0Ai+wXjMavqcy5rTddmz4wMAAIDWCL7BeMxr+pyw+u28jg9KPycE3iY1peu9IgYAAGBoBN9gJD7d3CyT+gJwl0d37jyu8gEx8HZe4yFeK2UAAACGRvANxuV1jZ/14ujOnXfxmW2Fhb9PXx+SmgNvMbgIAAAAg2K3UxiXsDrsRY2fNw2vozt3woq6t8nX564tPt3cLH5vRL5u0HASXz/Fn3V7q2gBAAAYoluyAMYlrFZLvgbNxmL56ebmByV7cPX4WfrjadXPSeuOfg5gmP3AJPn63Ni51e975d800xfO5AhAx+2yLIDReZ6MK/j2SpHS0cQlrOIsspI0TArDhiDX2VWhALEtCSvEw3NQw88naTsxlytb82qSfL3wchbza/XvoW19nubdlVzamnchz36KY8Djtd+t+qpwh8TbNB89RxdtsjaZllkRAOPsVMay+i0MFO+64n2QdfhZ0vHKtz3T8DJOENVZYNWWhP74Xfzf0D48kysb8+kk5tPxjj8Lk+RTbew3+RaCbuFC0aTE2xbp68KKOLTJh9Umx8BjOPaTOM86FXxsjw0XYJwuxnIcBtgMTNgl+F0c3ABQbEI4Sb4NvC3S15P09TD5elFjNRYIE8ZLOfZ1Ep2+3qT/GV6TtV+HyfQs81qfXE9iXyUvod3z9iSct+Hc62iseJb88Xzu8P2PlEp7BN9ghOKtb08GfhjXbougR8KV0Vvrr/Tf7yZfg92zzN+uVm8AUMyj5I/A21XavoZV7y/DOCB9PYlt7WI1eYyr5A55Ar9avXKW+ecQoAyPHgl5dy99nWZe99J//yH2V4vMe87Tz3qs+kFrzuLrPGlmk7o8FjV0SPANRioMWsMAdqDJXybjWb3HuM+zsPtvmCieJt8GvMOVzXM5BFDINNP/P9nQ1q4CS9kJ7EFau21sJYz5QtDt2bZnj4Y8jP3V3fj3KwvVDw5m3HqdmR/OkuEv1hgUwTcYt9CgDu0+/tXzB1yZYWgDmpdrk8OncgWgkFUgadfOplbDf3WZfBt4C4/oeFJm3BRXE4bVcPfcZQAHN169iHdwmG+1TPANxt24fglkJcMJwHnwJ0OXfTbR5NBvjQIoaLFqN3f8zeTQMylurpBd9Xex7w6wYaxlvAXQHsE3GLlMAK7vVzYF3hjL+XZtsghQyqrvn8SdCDfJBp0WB5pPLzL/fbVv4A2A9h3JAjiYgMDD+FDdFz0ddF8IvDESP2f+O6x8ay3wHVfahQnq/Q3n2Nv0HJt1NuD4upvh+Ya0hUn0++TrJivLDtMX8u1B8n3A9G1MW6eT/b7mX6xz4Rbrv4fnTcV/O45pfbCel/H27LbS9VPy/QOtw7nwug/9TQwy/ZRs3qmy0/O1A6+SP4JrYRfAe9n6HOvUale+ZXKAt6DGNmqSyYMnAz2O40w/tV73Q1t21VV7m6YttGF/C3m7qn99P0/71Ddk+oPXZW9nzrz3fVv9xKGqUk4V269wHj1f9b87+ulFPLeue5Jfk0ybld2hdpk5xxZqFrCxwU1fYXv533ryetHRVtv0u54+q6N+1ZiGZyXe9yLzvvO2BgYFz+sPbd8KG87v9HVZIG2/dLHrXhgQpq+PBdJ32UVbVaJsfylTT2tMXzZtXzYaiWnZls5pT/q4d22dC+GYs21JH9PYk3b/3VpbdZxpQz7s0x6PLH/eDDkPYjk+y2kfsnV/0nL6BnWe9rFvzeZX1b6kzbJuuW3LK6uzPpdThXFM9nw5XmvPtr0+Nj1mqOkc+y0eT26b5bZTODDxGR/hNtT17ebbNku+3mb6xMM+GZlWb42Kg9QPyR+7BWa/e311z5e/bXkn1rAr3/mGtM3W/i1MtEPg8rLFgVVYCfwm2byiYb3swjG8azMAF8tpU9luEtL1NBu06EC4kn6ZfHtlOGvZ5DlRMr+msTzbnjQ/iOdEn9PYlYeZNuskHvsk+XZnz6vVCssDlK0zV0NKeKYcn+5oH9aP9UMbgYgBn6e97VtrcDziczfvuMfY3k/W/vtjUmzH6kk8t87bTnA8nz9uOMd2jf1zL3ALvsGBymw3Hwa7bS7rDYOC07jDzkxJMCbrtwU1XcdjJ/8uM1ANA+8QWP8hnN/pK9y6dWttUhtctjFRiFfbs9/zPJO205i207XJwnlLV35D2h5vaJtuxXwL7eMPMc3LbECgpboUBuvZQNYypuVuTOOtTNlm2/BV0KKLycvZhnp4K/P6oalbMzL5lWxLQyzP7IWn4w4mzSeZMg0BlIdr5Rl2oHy5NhlrfRVQR+OS9U2iVpOfbODt4kD7lmy9WQzpFqfYFr1Z6wtC3b+3VvfvrrW3X97X0cqXIufpVVfnaQxG7NO3nid04Uksi1ny7QWoeebfZ7FOXY08LyaZc2sWxzA/7GgHVmPW1tqBDWPrJPbLRdqsdzZbA4o0NGFJ8OOCy4DLvj7Ez57IaQrWx8HddhpvUcneTnPZQj5tvE1rx99nl89/aDl9j0uk7byF9u63EmlbL9tnDafveO37ipTt+fot/S2dq+u301x20F4cr906vPMW4Q23vDRdntOytxZ10Z70KViz4dbEgzn+AnXo3cDS/mat7k8LlP+Htfcct5zHvT5Pe9y31nXb6bTFsn7W8vnwrK3jbKKcajq3itTb9XbgY4v5s97+nBRoBz6s3S67sc2y8g34IlxFDQ84TV8PM1fMwpWaEOmfJd/fvrZN+NuwCiNcCVhdzbgXP3shpxnhpGgSB9whmJVdpfSk4e8Ng7Zp5vtO827hjqtGfl9V0uYtPXkPUI5puxeP46rh5DzN/PdVgbTNY5u48qjh9L3I1KV5wbINeZZdFdTFBY9FRyuTwiB+ksmvnY8zCL8LfV3s366Sb1eateF53oOkY517mPmn80O4gBUnLNn6n2TaK8+H/er9gMoz9FHZfib3rofMCsjVmPE4+XaVsvO0v30rFPGyQL1dxnNr1ZdPWror4jz5Y1Xpamw9LzhG/D2t29oswTdgW0MyiwGzJ3EJ+72124e2vU5jAO9ZGLR4nhsj8VO8Urj+ClcN158JUSgQVoNsAKjMsxOfZ/77QYuTsPMC7c68pdvRzzNlVShIGgdXq4nLcVODwMxOgKXLNk6srrfUkVYmq12dn3vmV/jbi5b7qUXRnfziuZA9H6ZjbmRj3c8+x2qefP8MOAG4JPnLkPrOtQn3vGDdD+fkRYdtWdnzdN7VedqzvhVqGyvERRtXmX+630Lasm3N85Jt1pMtbd/vBN8AIN8kDqjXX+vC4Pa0aGdd0TTT6V8VfdPalfymJwlvM//9It5+3unkee02j7IXCLLHc9Jguf6+6m2PCVN2UNv2w8oXHZTnJPlj1dtiABPMsul7v9YOjVIm8Pb7892SrysJ1p8B9y7nluJpMn5Dep5Qtg16VeaN8VxetSnHLZdt2fP0bcvn6eu+9a1Q0LyH465sP7T+bMoybVb4++xKve/agiPlDwC1eFL0SnlNfn/49h7PLFnECUKjk4SQH2nafkr+eHj1izhRmMWgwjwOxBYt5lt2AjcpmXd/y/z3jy1MrN/ukefz9JiWMb8nB3DeZY9xPoD0/rxHEOBpw3WuD9Z3NL3ITIhOM79fBeC+WV2cDd6l/z3GjRkWW+p8b8WJZ/ZCwj7tfLhY9DjTNs6cp18n+bFvnfaob4Uiyq40b7MOZ8dfsz1XxYdz8CzTVn+TfsE3AMgXlp4/2zC5eJf8EcwJA+FWgm9rKwAmybfPMOuVcMt6fPh/9vkX00y+heMJg5NwJf9ly7cAfpOOktpYZbDvRHO+Oq7wIOCWVmL2wd9HfnyjXNkS24eTzITnYq0NWRYIwF1mPmN0+RSCKNmgeghsDSCwMqkw4V75xwDr/3FLdeK0x30r1Nn2dfHV+z5bM4xDzjLn4zfjOLedAsD+ss93OMnbvamHWgnKhGdrJV+3ZH+SbA4ohUlaCCB+HNAW7UN56LlbkeituDpq1W6uHrC9qQ1ZPYT/u1tQ44Y3Z5k27WKk2dXl8xzpoZH2rTBagm8AsP/AN0z0ss/YetrSTmfZoNms4GYom173Wsyr1Y7Kp3FH5XtxknyV+bPjOKFua5JwUSHvnrWQvume7zvUSdbftEqDk30m2FXeLrXJ9wG47IY3y3hOj3WFT/Y5X+cDeMbXYq1tp52+9W4P+tZEsI+B23dzh523nQu+AUA1LzOTjNWzV5oebC+TP27jGeQAN+6+tno2093MhDrkYZOrOmY1DK6aNC86iNsx4TmkiW52gj/VHA1Oto6/LdBurAfgVnV9tcv0aG+xXtv9Nhz3Zc/Tu8j2U3sGCx9sabvZke87+tY2H1Eh4CqPhibbf+w7tt75PsE3AKg20P2y2iLzT2fpJKONXSZXtyCF267Ohz5ZSL693eyswe+arZVV3wa/6+mblHz/owM7/0LdWcT/nRzIbpdjMtmjzJfJ94GYbD0Ys+dr7UPf2/5sOZV6LEM8l1cT2eUAdjIeQt/adPuYDV48KFHWx8lhXjyxOrB/4/n5vmPr+Pc7+zTBNwCo3mGHScFV5p9etBDUed3y95UWVmEVvfVk7eHhTR/LVeZ7LntWl5ZrdemyRH6Hycv5AZ6Cr7L5NYDb8fhD6fM+TnAeb5jEvht72ce+5uVafd/rnA/va+E5pdlz82nR/iCWY3YV+bVTZRB9a/ZZqGVuje7yeblt7yK97PC7aWhsHf8ud2Wp4BsA1ONJZlA1SRq+vWPDLUiFJp5hshUeUN70JDWu/vsQXkUmh2srlpq+dex5pqzO4gPb89IXVlW9aGlTjezqlmmR8or59+ZAz72rJLP6rci5ECevb9LXM01Xp7KT9acFzsNwrmbP14tkwyYMY86w+JD9bBt5Gety0UliaMvexHxstE1b66eSpMBzx+JxvEkyq97W2sSDtta3Pi7w9631rWl5XyffPoajSFt8nrS/Y/tyrY9ts83IBpLPhn7nwsjHE0Xr8Je/Swqs5BZ8A4B6Bp1hMJfd/fRxCw8cvki+ffZb2NHs2aaBQlzlEB5OHlYThMFe00Gkk7XJ4btNt+PG3QofJ98Gjt42XFaLtbIKefNhS/omMUDzIebZi6bLNaYveyvzeZxofbeSIKbvMg78jjdMLA7l3Hu4Vvd25dezmF+hvJ96MHinrpNvnwv2ZtOt1iGAEM7R5NuVnWFzhTBR2rgL6sjz7XQtkHIW2/+t7VMMOF/GtuysxbRm+6njeG4+Wy/n2Becx/RNM796srZ669Bl8+1Fn/rWVXkVbItPMkHgtvuM+VqA5TK2MdMWvjt872xtfPRi9f0tbdrF7vHExVod3ji2zrRZHzNj3tmuz78liwHomzg5rnwlNO78VUcanhfd3TIMhDMTh7AT6WnDeXWSfBt4WZlnJjzrA8ovwYomn6GTuRK4aSI4ywx6138/b2sX1jhoutyRvkny/ZXMkK+nbeyouCN9q7LdlL4waPwpU+anDZfzu7a+q0BazmJ+HZfIr8brW5zQvSvblmx4b+PtSUfltqmez+LkeNVGTNbar282V9jQ3lynv394AH1luJiy6UJK9tlFm/qAldWD+ZtO57Z+arFWzutWAdY28nIQ5+nA+9ZlLO+TDf++zJznjfclsb/YtFr8ZVxd2uR3h+P8kGy/DfhukwHnbL9dZZzc1vmRvv+3tvvAHXV4V5t1kXx758t37YiVbwCQr8wg6KLAhKc2cQIadjRbn6CcxO+fbhicNz6wDcGpONDP3uKZzZfphoFLeJZRa8GFzKqZxZb0rU/4nyctBd5y0neyIX2LmLarCnV30OItT6fJ91eeN+VX6/WtBsuRlttV8u3qqNU5GCY/Z2vlNosT0/l6e5N8vxrsEOr8ky11/jjTjk239GkP2wi85fRTky19QTiee20F3oZ0ng6ob324IX3HW8p6vZ9btpDG6w31MUla2AQhBtZ2tVeTAx5D96lfurehjDa1Wav2NLznb5l//658rXwDoHfiFaefaug8TyukIXSwL+Ig8EmZgEsm/e/LXD2vId8mccJ6P/ljlc9qBUR4ttJVF7fvxCv1Z5l0ncRB+CK+OktbJo0hfQ/W0re6NSXcqnPdVtBtR526nxn4rSYtX9IXJxLZY3nURv2LV7TDVd5506sF9kjXg1iW6/VtVZ6LFuv/i5iG5+uBowLvv9z3vQNr949j+/Ug+TZgtIh1/XXeRYP4GSeHuDNmXF3205bgy2oiOF9vLzpI565+apW+WUf1b1Dnad/71kz6Vm3xZK0u/n5OZ/qStsdN03jerNL2pM12dm3s8aW9azoo3uYYIfOdz2I9fVW2/any3gbqyDRTh1fjr6vM337MlOW9MffZAAAAANCa+My+3+Lrl01/47ZTAAAAAA5a3ADj3R6bMWWfVX0tJwEAAAAgI+7C+/vqtaIBuHDbeeZ9v9m1FgAAAAA2OLpz58NaAO5ZfH7hpr89Tl9v1gJvj7d9tg0XAAAAADhoMdD2Lvl245qwKcwsff09828/Jl83FMm6amsXaQAAAAAYpLii7cXaira81+O8z/2TrAUAAADg0P36+fM/09d/vX109D7+0yR9/XnDn4YVcf93+nr46ebm/8n7XLedAgAAAMAGcfOF7LPflp9ubuZyBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGLX/X4ABADdvGiZHZ1RtAAAAAElFTkSuQmCC" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https:/github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/mapping/sites_peace_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
