<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","knit":"pagedown::chrome_print","links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-21<br />
Date Revised: 2024-08-26</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p><br></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>This permit application can also be viewed online <a href="https://newgraphenvironment.github.io/fish_passage_fraser_2024_permit/">at this link</a>. A summary of sites to be potentially assessed (including historic fish presence information available in FISS) is included as Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a>. Details of fish species known within each watershed is presented in Table <a href="#tab:tab-fish">4</a> and an overview map displaying potential sample locations is included as Figure 1. A kml file of the sites is included as an attachment to the application and can also be downloaded <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2024_permit/raw/main/docs/sites_fraser_2024_20240826_kml.zip">from here at this link</a>. There is an extensive amount of information contained in the kml file (accessed by clicking on sites) including brief summaries of background reporting data (when available).</p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Society for Ecosystem Restoration Northern BC, the Ministry of Transportation and Infrastructure (MoTI) and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. These sites were selected from 177 sites assessed for fish passage in the 2023 field season or through <a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/">past effectiveness monitoring work for MoTi</a>. Although incomplete at time of permit application, background reporting for 177 sites assessed for fish passage in the 2023 field season can be viewed below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
</ul>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dipnetting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmations and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. Our study plan is (when time allows and PIT tagging is expected to increase our state of knowledge about the subject system) to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and insert biomark APT12 PIT tags into the body cavity of select fish captured over 60mm. Fish location (UTM), length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year timeframes. Main objectives are to determine</p>
<ol style="list-style-type: decimal">
<li>if fish are moving into restored areas</li>
<li>if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150 however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:left;">
wsc_code
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
5400202
</td>
<td style="text-align:left;">
Tributary to Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388986
</td>
<td style="text-align:right;">
5997007
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:right;">
5400203
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388277
</td>
<td style="text-align:right;">
5996946
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:right;">
5401774
</td>
<td style="text-align:left;">
Sheraton Creek
</td>
<td style="text-align:left;">
180-374000-95200-01900-6160-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
337849
</td>
<td style="text-align:right;">
6006826
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:right;">
9902577
</td>
<td style="text-align:left;">
Beaverley Creek
</td>
<td style="text-align:left;">
180-069000-07200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
502369
</td>
<td style="text-align:right;">
5962508
</td>
<td style="text-align:left;">
LCHL
</td>
</tr>
<tr>
<td style="text-align:right;">
13900077
</td>
<td style="text-align:left;">
Hankins Creek
</td>
<td style="text-align:left;">
100-842800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
691820
</td>
<td style="text-align:right;">
5904863
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900100
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650785
</td>
<td style="text-align:right;">
5934862
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900201
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965783
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900260
</td>
<td style="text-align:left;">
Tributary to Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587920
</td>
<td style="text-align:right;">
5972459
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900308
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
100-705400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
607112
</td>
<td style="text-align:right;">
5971290
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900309
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
100-706300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
608028
</td>
<td style="text-align:right;">
5970651
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13903184
</td>
<td style="text-align:left;">
Kenneth Creek
</td>
<td style="text-align:left;">
100-683800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
582280
</td>
<td style="text-align:right;">
5975076
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13903452
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
604850
</td>
<td style="text-align:right;">
5973075
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
15600119
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15600122
</td>
<td style="text-align:left;">
Redmond Creek
</td>
<td style="text-align:left;">
180-305100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
420920
</td>
<td style="text-align:right;">
5993688
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15600277
</td>
<td style="text-align:left;">
Tributary to Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
399102
</td>
<td style="text-align:right;">
5996464
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15600285
</td>
<td style="text-align:left;">
Nine Mile Creek
</td>
<td style="text-align:left;">
180-350800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403917
</td>
<td style="text-align:right;">
5998779
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15602716
</td>
<td style="text-align:left;">
Tatsutnai Creek
</td>
<td style="text-align:left;">
180-360100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400817
</td>
<td style="text-align:right;">
5997662
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
19702017
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521562
</td>
<td style="text-align:right;">
5976182
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:right;">
22201176
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344030
</td>
<td style="text-align:right;">
5862738
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:right;">
22201229
</td>
<td style="text-align:left;">
Holliday Creek
</td>
<td style="text-align:left;">
100-864700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
305966
</td>
<td style="text-align:right;">
5896003
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:right;">
24715754
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
100-654700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
576133
</td>
<td style="text-align:right;">
5992812
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:left;">
sp_upstr
</th>
<th style="text-align:right;">
fish_tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
5400202
</td>
<td style="text-align:left;">
Tributary to Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
5400203
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
5401774
</td>
<td style="text-align:left;">
Sheraton Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
9902577
</td>
<td style="text-align:left;">
Beaverley Creek
</td>
<td style="text-align:left;">
BB;CAS;CBC;CH;CSU;DV;KO;LNC;LSU;MW;NSC;PCC;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900077
</td>
<td style="text-align:left;">
Hankins Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900100
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900201
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900260
</td>
<td style="text-align:left;">
Tributary to Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900308
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900309
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13903184
</td>
<td style="text-align:left;">
Kenneth Creek
</td>
<td style="text-align:left;">
BT;CC;CCG;CH;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13903452
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600119
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600122
</td>
<td style="text-align:left;">
Redmond Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600277
</td>
<td style="text-align:left;">
Tributary to Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600285
</td>
<td style="text-align:left;">
Nine Mile Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15602716
</td>
<td style="text-align:left;">
Tatsutnai Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
19702017
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CH;CSU;LSU;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
22201176
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
22201229
</td>
<td style="text-align:left;">
Holliday Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
24715754
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
Species Code
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
SARA
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Upper Fraser
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
WSG
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
1-E
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
GC
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus bondi
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
MSU
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
T (Dec 2022)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
LSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
BSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
WSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
CSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
FDC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
LW
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
CAS
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
CCG
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
CRI
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
LKC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
CP
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
BMC
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
BB
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
LMB
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
PCC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
CT
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
PK
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
CO
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
KO
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
SK
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
CH
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
PW
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
MW
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
NSC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
LNC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
LDC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
ABT
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus pop. 26
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
BT
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
NAR (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
EB
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
LT
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
AO
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
SLV
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
CBC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
DC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
C
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
PDC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
CC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
SU
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
WF
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
