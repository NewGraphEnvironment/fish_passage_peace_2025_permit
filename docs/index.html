<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML and GPX file of all sites is attached to the application and can also be downloaded <a href="https:/github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/docs/sites_peace_2025_20250725_kml.zip">at this link</a> (or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a> if this is not the latest version of the memo). The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
