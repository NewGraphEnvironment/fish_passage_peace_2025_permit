<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/lucy-schick/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/lucy-schick/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://lucy-schick.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://lucy-schick.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABN8AAAGRCAYAAABVBRUGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAV3pJREFUeNrs3T+UE0m+KOiEqXOYtabaG2+Et14X3l0LlXfXovDuWl1lrgV4uxZgPguwdteqwnr7LApvn4Ww9j0LjXc91N5dqzXe1DnQvRkQ6k6EpMxU/k993zk61U2VpMiIyPjzy8iMJAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgKM7d07S14sepec8vJQMAAAAAIMWA2+/pK/f+hCAi4G33+LrXAkBAAAAMEhrgbfOA159Sw8AAAAA7GVLoGv1mnaQnuMd6TlXYgAAzbstCwAAqguBt/THu/R1vOVP3oRgWMvJerMjPZcCcAAAzRN8AwCoqEDgLYm/e9Nimp6lP6Y5fyYABwDQsD/JAgCA/RUMvK1Mbh8d/ePXz5//Wwtp+s8F//wsTdPPaZrmShMAoH63ZAEAwH5KBt5Wlunr7qebm2WD6fqQ/jgp+baLNE1XShUAoF5uOwUA2MOegbck/v2LBtN1npQPvAVuQQUAaICVbwAAJVUIvGWF1W+LmtMV0vOxYrqsgAMAqJGVbwAAJdQUeAueNpC8xzWkywo4AIAaWfkGAFBQjYG3lVpXv6Xp+6XGtFkBBwBQAyvfAAAKaCDwFjytMX3nNafNCjgAgBpY+QYAkKOhwFtQ286ne+5wWoQVcAAAFVj5BgCwQ4OBtyR+5lkNaZwkzQTeAivgAAAqEHwDANii4cDbyoMaPuOs4awQgAMA2JPbTgEANmgp8PbFp5ubWxXT2tQtp+vcggoAUJKVbwAAa9oMvMXvO6vw3pDGk5ayxgo4AICSBN8AADLaDrxF9yu8d9pyFgnAAQCUIPgGABB1FHgLqqxcu99BVgnAAQAUJPgGAJB0GngLphXee9JRlgnAAQAUIPgGABy8jgNvqzRM9nzrSYdZJwAHAJBD8A0AOGh9CLxFkz3f13W6BeAAAHYQfAMADlaPAm/BZI/0T3uSlQJwAABbCL4BAAepZ4G3YDLwLBWAAwDYQPANADg4PQy8jYUAHADAGsE3AOCgjCzwdtLDNAnAAQBkCL4BAAdjhCve+nocAnAAAJHgGwBwEEZ6q+myx2kTgAMASATfAIADMOJnvM17nj4BOADg4Am+AQCjZnOFzgnAAQAHTfANABitgQXeFiMuCgE4AOBgCb4BAKM0wBVviz3eMx9QkQjAAQAHSfANABidgd5quij7hk83N8uBFY0AHABwcATfAIBRGeoz3j7d3Cz2fOtsYEUkAAcAHBTBNwBgNAa8ucKswnvnAywqATgA4GAIvgEAozDwXU2rBND+PtAiE4ADAA6C4BsAMHgDD7wF7yu8dzbgohOAAwBG75YsAACGbASBt/C8t1sV8+Bj+mMy4GK8SPPgSm0GAMbIyjcAYLDGEHhLXffkM7pkBRwAMFqCbwDAII0k8Ba8reEzXo+gSAXgAIBRctspADA4Iwq8LdPX3U83N8sa8uRD+uNkBMXrFlQAYFSsfAMABmVEgbfguo7AW/RqJEVsBRwAMCpWvgEAgzGywFsQVr0tasqbkCcfR5Q3VsABAKPwJ1kAAAzBCANvV59ubmp7Vtuvnz//8/bR0f+Q/ud0JPlzlh7Pz+lxzdV+AGDIrHwDAHpvhIG3oLZVb5l8Gtvqt8AKOABg0Kx8AwB6baSBt1pXva2McPVbYAUcADBoVr4BAL010sBbbTuc7si3sPptMrLqYAUcADBIdjsFAHpppIG34HmTgbfoYoRVwi6oAMAgue0UAOidEQfeZp9ubv7Xpr/k18+fF7ePjkLe/cvI8s8tqADA4Ai+AQC9MuLAW1jt9j+F57K18WW3j47+e/rjX9PXX0eWjwJwAMCgCL4BAL0Rd+v8kIwv8Bb8z59ubv69rS+Lmy+EANy/pa8/jywvBeAAgMHwzDcAoBdi4G2MK96CsFnArO0vTb8zBKcuRlplPAMOABgEK98AgF64fXT0n9Mf0xEe2stPNzf/qasv//Xz538Pq8TS/zwbYd5aAQcA9J7gGwDQuaM7dx6nPx6P8NCu2thgIU8ITgnAAQB0Q/ANAOhU3GDhzQgPLQTeenPLpwAcAEA3BN8AgM7E57yFwNvYduQMz3h73rdECcABALRP8A0A6Mzto6P/Lfm6G+eYhMDbVV8TJwAHANAuwTcAoDVhpduvnz//M/73JBnf7aa9DrytCMABALTntiwAANoQN1XIuhzZIQ4i8LYS03ox0up2mda3c2cdANAHt2QBANC0ozt3nqU/Xn66uVnG/5+mP96N5PDCMZ2mxzYfaNmcJ+MLhK4MKiAKAIyT204BgEYd3bnzIv3xXz7d3CxW/3b76GgsmywMOvAWuAUVAKBZbjsFABpzdOdOWFH1PhucSv8tBHlORnB4gw+8rbgFFQCgOVa+AQCNiIG3nz/d3Pyf2X+/fXT0f6Q/JgM/vNEE3lasgAMAaIZnvgEAtYuBt5NPNzf31v59mgz/WW8hgHO6en7dCMvuPPEMOACA+sZXsgAAqHVw8TXwdp6+7m349U8DP7xRB96CEJxKyzD85xgDcOEW1EQADgBok2e+AQC1yQTeXq7fkpn+7jgZ9i2Now+8rXgGHABAfTzzDQCoRSbwFoJTD3/9/Pmf2d/fPjr6t/THvw308A4m8LbiGXAAAPWw8g0AqCwTeAtebQlSPRjo4V2FZ9cdUuBtxQo4AIDqbLgAAFSyFngLAaq764GqeMvpLwM8vBB4u1DGNmEAANiXlW8AwN7WAm/B9ZYVYtMBHp7AW2QFHADA/gTfAIC9bAi8Bc+3/Pn9gR2ewNsaATgAgP0IvgEApW0JvM0/3dwstrxlOqDDuxB420wADgCgPME3AKCULYG34PWOt50M5PA8/yuHABwAQDmCbwBAYTsCb8Fsy3umAzk8gbeCBOAAAIoTfAMACskJvC0/3dzMt/xuMoDDE3grSQAOAKAYwTcAIFdO4C2Y7fjdpMeHFnZmvSfwth8BOACAfIJvAMBOBQJvwd93/O7Hnh5aCLyd7lixRwECcAAAuwm+AQBbFQy8BbsCWMc9PDSBtxoJwAEAbCf4BgBsVCLwFiwHdGgCbw0QgAMA2EzwDQD4TsnAWwi8zAZyaCHgdlfgrRkCcAAA3xN8AwC+UTbwNiAh4BZWvC2VcnME4AAAviX4BgD8TuCNOgjAAQD8QfANAPhC4I06CcABAHwl+AYAjDnwdvXp5uaewFs3BOAAAATfAODgjTzwdqGEuyUABwAcOsE3ADhgLQXeuthZVOCtRwTgAIBDJvgGAAeqzsBb+lknO379j5YPTeCthwTgAIBDJfgGAAeogRVvxzt+N2vx0C4E3vpLAA4AOESCbwBwYBq61XTXyrdFS4d2EYM79JgAHABwaATfAOCANPiMtx+3/eLTzc0iaT4AJ/A2IAJwAMAhEXwDgAPR8OYKJzm/nzV4aAJvAyQABwAcCsE3ADgALexqepJ+x67nvr1v4DuX6etU4G24BOAAgEMg+AYAI9dC4G3lbMfvrmv+rlXgbaaEh00ADgAYuz/JAgAYrxYDb8Hy18+f3276Rfrv/7x9dDRJ8m9PLfQ9ydfA21wJj0NaP+Zp/fg52R3AHaqzcGzhGJU0ABwmK98AYKRaDrwFeYGT1zV8h8DbSFkBBwCMlZVvADBCHQTegj/vWuGT/vsi/X0I0P11z88PnxsCb/+uhMfJCjgAYIwE3wBgZDoKvK0c//r589YVbrePjm6S/QIrq8DbfyjhcROAAwDG5pYsAIDx6DjwtnL3083NYkca36U/piU+bxV4Wyrhg6rLoR5fjvTwLuzSCwCHw8o3ABiJngTeguNtGy8EcVVT0XQKvB0oK+AAgLEQfAOAEehR4C04uX109PrXz583Bszis9+O0//8l5zPuUpf/4vA2+ESgAMAxkDwDQAGrmeBt5W81W//Pf3xb+HvtvzJ1aebm4v0M/6phA+bABwAMHSCbwAwYD0NvAVh9dv7sMpt0y9DUC38PvkagPvz2q+/BN6ULpn6IgAHAAyW4BsADFSPA28rJ79+/vx/bftl+rv/uH109P8l3wZUBN7YVl8E4ACAQRJ8A4ABGkDgLfjr7aOjf/z6+fN/2/YHawGVJ59ubv53pUvB+jI2AnAAMFK3ZAEADMtAAm8rYbOEsFvpPOeYJunfLJQuBc+BUP8vR3p4F+m5cKWUAWA8rHwDgAEZWOAtCM9z+5fbR0f/ZdfmCdt2RoUt9cUKOABgMATfAGAgBhh4W/lreO3a/RTKEoADAIZC8A0ABmDAgbeVk7znv0FZAnAAwBAIvgFAz40g8Lbyr4IJ1E0ADgDoOxsuAECPjSjwlnUvbwMG2ONcCeeJTRgAgN4RfAOAnjq6c2ea/ng3wkMrtAMq7HHOnCfjDcDdtSMwAAzTbVkAAP2UTrRn6Y+LER7acfp6d3TnzolSpuZz5mqk58yFwBsADJdnvgFAj434eVZ/Tl//lh7bf02P8T+UNDWfMyHA+y8jOSS3nALAwLntFAAGYMS307kFlabOmTfJ8IPWAm8AMAKCbwAwEAJwUOp8CavfPiZfb3MeIoE3ABgJz3wDgIEY8fOsPAOOJs6X5YDPF4E3ABgRz3wDgAHxDDgOXVjRltaT/zd93YTzIed8+ff070JQ938c0CEKvAHAyLjtFAAGyC2oHGi9/7JKMn2tVkmexl2Bd71nkv74kAzj9lOBNwAYIbedAsAAuQWVQ7Mh8Ba8yasr6bmySH+8GsAhCrwBwEhZ+QYAA2YFHAdSzzcF3lbmsa4sc97f580XBN4AYMSsfAOAAbMCjrHLCbwl8d8vc86TEJi76ukhCrwBwMhZ+QYAI2AFHCOt13mBt6yHaT253vFZk+Tr6rc+EXgDgANg5RsAjIAVcIxNycBbcBnfs+0cWaQ/rnt0iAJvAHAgBN8AYCQE4BiLPQJvq3ryIudvXvfkEAXeAOCAuO0UAEbGLagMvP7uE3jLurerjqSf/0vS7cYLAm8AcGCsfAOAkbECjqGqIfAW5K1+6/LWU4E3ADhAgm8AMEICcAxNTYG3YJpTP952dIgCbwBwoATfAGCkBOAYiliWdQTeVh7t+N2sg0MUeAOAA+aZbwAwcp4BR8/r5yrwVvdz2H5I68Zyy3eG75u2dIgCbwBw4Kx8A4CRswKOvmow8Bac7fjd+5YOUeANABB8A4BDIABH3zQceAse7PhdG6slBd4AgC/cdgoAB8QtqPSkHjYdeFvZeOtp+v2T9MfHBr9X4A0A+J2VbwBwQKyAo2stBt6C6ZbzYNHgdwq8AQDfEHwDgAMjAEdXWg68Bfd3/G7WwPcJvAEA3xF8A4ADJABH2zoIvAVt1gOBNwBgI8E3ADhQAnC0paPAW7CrDtS546nAGwCwleAbABwwATia1mHg7Us9SL+/6e8VeAMAdhJ8A4ADJwBHUzoOvK00Wf4CbwBALsE3AEAAjtr1JPDWJIE3AKAQwTcA4AsBOOqS5vV5IvAGAPCF4BsA8DsBOKqKgbfLpD+Bt2nNnyfwBgCUIvgGAHxDAI59ZQJvYyXwBgCUJvgGAHxHAI6yehx4W9b0OQJvAMBeBN8AgI0E4Ciq5yve5lv+/S8lPkPgDQDYm+AbALCVABx5BnyradGyF3gDACoRfAMAdhKAY5uBP+OtyIYQAm8AQGW3ZAEAUMSIH6Yfngl2+unmZq6Ux1cf0nK9tSX9v+W8VeANAKiFlW8AQCFWwLEyoEDsckv6pznvE3gDAGoj+AYAFCYAx8BWQG5bzbirnAXeAIBaCb4BAKUIwB2uAd56/H7Lv9/f8u8CbwBA7QTfAIDSBOAOz0Cf+TffcByhjM82/K3AGwDQCME3AGAvAnCHI82LEHQb4mYbsw3/JvAGALRK8A0A2JsA3PjFwNv5AJM+T+vnpg0XHqz9v8AbANAowTcAoBIBuPEacOAteL3heCbJtyvfBN4AgMYJvgEAlQnAjc/AA2/B9YZ/e5r5b4E3AKAVt2QBAFCXgT6Uv4hw++Lpp5ub+YGU49ADb7O0rE7XjmmS/vgY/1fgDQBojZVvAEBtrIAbvhEE3oLXG/5ttepN4A0AaJWVbwBA7ayAG2y5jSHwtkjL5+7acU3TH+8SgTcAoANWvgEAtbMCbnhGEngLXq8dVyizcGwCbwBAJ6x8AwAaYwXcYMppLIG3UC5303JZrh3be4E3AKArVr4BAI2xAq7/RhR4C56vBd7CcQm8AQCdsvINAGicFXC9LZcxBd6+edZbemxn6Y9jgTcAoGtWvgEAjbMCrl/Cc9BGFnhLNtSvpcAbANAHVr4BAK2xAq4XZfAlYJi+xrRpxHWa9w+dYQBAHwm+AQCtEoDrNO/HGHj7bpMFAIA+cdspANAqt6B2Y6SBt+ChwBsA0GeCbwBA6wTg2jXiwFvY3XTmjAIA+sxtpwBAZ9yC2koejzXw5jlvAMAgWPkGAHTGCrhmjTjwNh9pvQEARkjwDQDo1AEE4CYdpuFFMr7A2yL5uqrQc94AgEEQfAMAOjfyANybuAKtVel3hsDb+cjyMwTcbLAAAAzKn2QBANAHv37+PL99dPRz+p9nIzu0v4ZXenxv2/rCozt3Qh6+HFk+9uY5egAAZQi+AQC9MeIA3El6XH9Pj+/fm/6izHPe/jyi/BN4AwAGy22nAECvjPgW1MuWbj8Nu8cejyjfBN4AgEETfAMAemekAbgQEHvR5BfE203HtGpQ4A0AGDy3nQIAvTTSW1DD7afv02Nb1P3BcVXdm2Q8q94E3gCAUbDyDQDorZGugHva0Oc+Tl+TkeSRwBsAMBq3ZAEA0HdHd+6cJ1+fZTYWIbA0qzF/wmq3j8k4Vr0JvAEAo2LlGwDQeyNcAVf36rew6k3gDQCgh6x8AwAGY2Qr4O5+urlZ1JQvYdXbZOD5IfAGAIySlW8AwGCMbAXcozo+JO5wOhl4Xgi8AQCjJfgGAAzKiAJwde3i+tPA80HgDQAYNbedAgCDNJJbUCttvBA3WvhlwMcv8AYAjJ6VbwDAII1kBdyDiu8/G/jxC7wBAKMn+AYADNYIAnDTiu+/P+BjvxB4AwAOgdtOAYDBG/gtqD98urlZ7nncQ93l9CIGTgEARs/KNwBg8Aa+Am66z5uO7tyZJAJvAAC9J/gGAIzCgANwJ3u+bzLAYxV4AwAOjuAbADAaAw3A/bjn+6YDO06BNwDgIAm+AQCjMsAA3PGe7/vbgI5R4A0AOFiCbwDA6AwsADf2204F3gCAgyb4BgCM0oACcMcjLgaBNwDg4Am+AQCjNfBdUPOc9Dx9Am8AAIngGwAwciMOwPV5xZzAGwBAJPgGAIzeyFfA9Y3AGwBAhuAbAHAQBOBaIfAGALBG8A0AOBgCcI0SeAMA2EDwDQA4KCMKwM16lBaBNwCALQTfAICD07MA3HLg2SnwBgCwg+AbAHCQehSAm+/5vkUP0v5S4A0AYDfBNwDgYPUkALfY830/d5zuqzT/nqhFAAC7Cb4BAAetBwG4fYNo8w7THAJvNq4AAChA8A0AOHgdB+Bme76vq+CbwBsAQAm3ZAEAwFdHd+6cpz8u2/zOTzc3tyqk95f0x3GLyRV4AwAoyco3AICogxVwVVevzVpMq8AbAMAeBN8AADJaDsC97fj9RQm8AQDsSfANAGBNiwG464rvn7WQRoE3AIAKBN8AADZoIQC3SL9jXjGNi6TZAJzAGwBARYJvAABbNByAe1XT57xuKH0CbwAANbDbKQBAjoZ2Qf3h083Nsoa0hd1OPyb17noq8AYAUBMr3wAAcjSwAu6qjsBbTFv4nKua0ybwBgBQEyvfAAAKqnEF3N34vLa60jVJvq5+q0rgDQCgZn+SBQAAxfz6+fP89tHRz+l/nlX4mBDgel1zupZpusJtp/9SMV0CbwAANbPyDQCgpAor4MItovfqXPWWSVOVZ78JvAEANMTKNwCAkiqsgPtPn25urhtK0z/TNN2k//mvJd8q8AYA0CAr3wAA9lRyBdz8083NvRbS9CH9cVI0TenrtK7NHwAA+J7dTgEA9lRyF9S2VpcV/R6BNwCAFrjtFACggoK3oD5p6nbTDen5jzQ9/0h2334q8AYAAADAcIRbUNPXbxtelx2l53JLej7EzRkAAAAAYDg2BOA6C3SF743fL/AGAAAAwDhkAnCdB7rWAnACbwAAAAAM39GdO2d9CXSl6ThJX28E3gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgHrckgUAAMDK0Z075+mPB+nrOPPPbz/d3LyUOwBQnuAbAAAQgm4h2PYmfU23/Mk8fZ1+urlZyi0AKO62LAAAAFKXyfbAW3CSvt7JJgAo50+yAAAADtvRnTshsFbkttK/3j46+vnXz5/ncg0AirHyDQAAOCvxtw9kFwBDEx6vkL4u09eH9PUxfb1JX2etfLfsBwAASjiWBQAMSXyuaXh0wknmnyfp6yz93cWnm5urRr9fEQBA7wcLYZDwournpIOKU7kJAMABepx8G3jLepGOt6+b3FBI8A0A+i9cqZvKBqBBixJ/63lvAAzN/ZyxdgjMzZr6cs98AwAArtNX0Sv+r2QXABQn+AYAAAcu3mrzpMCfPk//diHHAKA4wTcAACCJD5u+SDavgPsSnEv/5pmcAoByPPMNAAD4IgTgwkOn0/88S77uAhcs0lejD6IGgDETfAMAAH4Xg2xXcgIA6uG2UwAAAABoiOAbAAAAADRE8A0AAAAAGiL4BgAAAAANEXwDAAAAgIYIvgEAAABAQwTfAAAAAKAhgm8AAAAA0JAjWQAA0MKg686d4/THSXwdb/mzZfqap6/Fp5ubxUjzYZrJg7+lr8na8f89/vcqH+ZqT6m8XR5ynqV5sDrHJhvqVzinfo4/513lU5rGSUzXrrYgmB1SeWbayGn8p23lt8qbMbeTk8yxn2TaxKSL445ty8o0lsUqDeFcWo64DIr02WPNg/Vxy64+e9TnZB1uyQIAGMSE+l3Vz0kHRPr99getZ+nrfpysTEp+xDIOZt+mr+uuBvbpcYRjeJFJfxhYP0/Tc1ViAhM+46fMJLKX+RDT+jR9ne9zrB3WtWfpj0eZCWJI90Wa7lmFNudFprzC571KP+9lg+n/aa2OFf6+WEcfxHp2XOKrw/e8Tr/nWQuT+GxbcLzHx4SyfB/PgXmP6t7jWPcm+9S9GCz9KebLvu3DdSZvlh3nx3StLr8tUo/X6shZiXZxddyLGo9hn76rF/1VTcf9YM/zdLHKg/T4rzs8jk199pOiaarpnOxlXUiP7V3yR3B/k9N9+80ibg3gBMgW+KgiqWtXNJJMRcgW+Cij6PS+bmav8Kz+e1Uvl1Yh7NWOtdJ+rZXdNPnjipyyG3D970PwbS1fkiYHJyOoQ6vJ13nNH30VAxLzFo8lDOLfbPn1w12D+ZgPT3MGuvu4jvkwq/lYw5jsw5YJ12lf63ya7lDPLrf8+l7Z+pLT3jypOwAXgzcvtvz6YlfgMx7706R8YHvdPJbxssbjWk3kH+05gc2b5L9OXy+7nCfklN3OcyaWXd15swrEPe9izrjjXAzzuXs7zrdHSbGAW6PtYubiQ9kgdq/KYc8+u44y6DwPcvqDLs7JTsYuO46xv8G3WBGrDpgWRa4WrkX7T3I60d+Xd6av911Glks2ZtPM8ZWt1LPV8Yb/bqKjjVcdK59cVRuYeOJPakjLouqV6lhu513nSUvBhtWKhKLn/DzWy0LnYE3lOivTINZUfkmZK+Jxorq6Upg9z583cWV9x/cVKbvXRTrCmtqGsmVXR/9TqOxi/c/mY+31v6aBYSvBtzhhzPZX0wJ5ke2fej/QbrgtfZHUH2zaNCa4aCmg/2FH2xL62btb6uvTlvLheV0D5TTdlzv6jFC3T3ta7z7u6F/DqoOHJT/vzY5JaLgA8UOL6d8YtIh17LKm8WJ2vHZRw/GENnS1Guy4hSpwlXQXbPplxzFurHsbVuWMIl9iuX/ckR/fBJLjGPVFzQGf1XE/KTNXjGl/kdR/waix8W+NY6s2+qrW6mLPz8lGxy4bVoC35Tqec7nHdavAATytYcJ1mjMhrxph7WV0PTZk58n+t1nkFfLbOm+DyBn8tNbA5jQatU80c9Ky64peobpZ9yC15vr5OPl2aXyVc/BVsuMKbIErDbXXr7YCFgWvFNY2+MgEFesou0Usu6sdZfdb24OvmvqfnWVX44qJZfLHVb2mBhSN1+Uar/yGwdXrvt+m10B7+jS2qW163sLtcr8VrVMd5sPLmBfLisfa6RXxPdMc2rHLfcfhe7b59+pcwdCjOlY5wBonsZcdTP6WsQ961mLdy+uXvhkDx7HLZQuBjk6CPzmrhL8JfLRQT5YxyHHdkzo7j+npxd0XsR25TOoPfOaVyfOmbt2PxxXiDR9Ktqdt50Mj52Rd84aK86l7eeOQ2x1W+vMY7AkFXjUwtQpyfQxXLWPj3uUJPYlXTz8m3z4vo05fGsoQqAqVLZ48lQcdNXzGjzUEFY5rLItpl8dTU57W3uHEBupjTYGH1Tn4NJ6Dz5IDEfPyRczL86YH2w2V3SS2Ux/jJO4Qyu0s0//UVf8fZ/qg44HlxzQGHd7VNACbxv7pYw1t8BDybzXYfdzB1z8NK9O6Hvf0IB/Cd36IaWjSox5WwZ8KTPjqdtxRHTuO7dTjHrYDx7EdfdNR/hxn2oOTnmTLcbbfje1DF33CKl+aLpeTIvkRx41N15Pw2W/yxnVxvtpGnQ15864PdTOOSz4m7QecvqwuDCuLG6yLxwPIh6bGLl33z5MieXm7gwp/Em9hqHup+Mp5HIA97uDYshPjxifiG4IeVY/5bQsdT5FJW52mNZxIVbzv2yQ7Dn6eNlQ/+zj4a7rzftzS950lfwTdmmpLQsDk3dCCRyXb6DdxoNlUsOI8tsdnA8mPF3Ey28SEaBIH229GXKfOY/5NOkzGSdJO4Cmvfeo6H1b1rUpdfp3z+7M+BDrX+qG84307knNtFXhrsp6/3TNtJ7F/nvYgq1ZBjvOetZNdBSWz+fKx67FpDHa1OUe93HZRPOc2+6bGme867qsex3aky7p41oN8OO9BPtQ9dunDODN3fHC75YI+a6HjXGX+izZXIKwFNbqwOuZ3FQaGszoqXcU8v19zvlRduVZ1INWb5xHGzretyVFvrnA1nJdttS9tXCXN1vmPYyu72C7WtbKrSHv8ps+r4GL5trWC5GyM7UHmdr99y3gR+93sazG0SU1PJtbr+bDXeR5vlc4rg6c9qoZ5V/oXY7j9u6XA29U+t4PF+v+hhvq/rKEdyJ4Hl324E6HAbdFdtA9d9UVhfHXewfc+XQ/GdhB460NfFY65yqOE6uyzT5Ju++wxnpN92KAytz4cjbygw3eGlXanDW9LX/W5YHU37CGKfFH2IeAhj9L3zWsY3Jwk+wfypg3kR5XJaaUTsC/PIOyokz2OdfF0TLsitpmXLU04dnWGp2PYHTVnB8PB90F7tm1tX/E8GVmd2mdME447rKya57WJsYxC/1XmmbFdnbdl8mEVYHgf8+O73YPjxczVLtFlNkH5Jk3p5yz2zIfnOccUHpvS+TOGMxuV5R3LGBR9hMvqGdB/j/VrvqntzexC/vu5uU8bXWFus4jpfB+/e7FjDLBqCx7sMRYIQZe/1bGJREvtwyq4sSq/b8bRmfxY/dwnT1bt5N0+9csbrNrJJDOnWrWF+7SLoU0MdW0eL+iWGccuM+Wy2vRwVQZ/Scpt+LUqg8s2x0Z7jt3DMYfVsLO8viSzCrlMneyqLlY5J7/ps2s+J+9V7Fevkm4fSbDqf3bXxR4PUusc8Icrsqc9OpnbmDi/iQG4q5LvfZvUc+vobI+8DOme1J0XYRKz5wC8aj7M+lAZcnaqa0Ooi73cIa7P53uHgbfvBgUDL7PjpNtVOdmg07IH+dFF4G1ok568PDwrOaYJ/XCpYE3ss8LrZWZDl/OCefwmDmL7lMchD94WuSiYCUxeZ87hkOdlNueqUteuY7Bn1zkSyuJZx3matwJvOaJNT/Lqfqgzr4pedI51YlaxHdhnbnMV0zkvmc7wepbZbKnMbn4hWPxzX3ebLJMva+V2ncmTVfswKdM+pK97PcuH0EeEgPn1lnZrtja2OUvKPf83BLyelwhQ5J1X15n0lK2bJzHtT1qKQ5QZu79MSm6gFfut1Xm6OrazonWxbxdpK56Tx5m6UOacfFMlH9L3PUnfv+ov2h7jhjwotMNwG7edTpLuV4VNY5R/sBPxPV3u8cyHWQ3fu++tntOmyr/l41jp/DkrsY52favXcdKf5c1V8vJZy+f7u56U3ZuBF10fzoFVAO64J/lx3HGdejfgdmBSoj0Lg9YQBLuocjU3vDeuXLkXP7PIuKsv520YjN+NeXC95/F/CSKlr3D8D5Pit/ns1ffEwfOrnD971OX5nJnc7PIqGb9wPoTJ2um+9WvP/D8pObfJngfzim1BGIvcTcqtanza0w2VrqrmS8yTl+kr5EkI5BSduJ/0aIOwZZy4341t3bLAca+C6/dK1IWTgn3Doux5lamb90rMJR83fdtl/PzLkufpk4p99jzuantasL9aBevGck4uM+fkRZlzsmo+xLL7Iezouu1VoH6e7nr/llfhOw7aCr71YcLxuM5d1wYQePt9olWmw42R+6qR930b0vsN5cH9lo9jZdZlwXcQLMrLy2kyUHGly9MWv68PAaOVwZZbdNajc+CyJ+noPA0D3hW56CrKsNLtXp23f8YB/b04OM49b7vYeGptMvkwTEDqvD0zTgSL5sGX83/P57+9zBkLrXY47mxMWyD/XybjtjrHWh1rlVxN3dR5sMwE4Yq2MS969NzNRZzgXtScLy9jnhStE097kCerizQvK9aFum4tvo7pme2ZnhCEOy3RRr9o4Vwt4kkD5+ks9ldFApiPO94dvqlz8iqek0UvjnSdD427nRyWy5pO5sfJMAJvvx93yc6l6kBm300XmjrZ9u1Yq6Rn3uXy4dhwPU3oVdtRsOzOB9a+UNxZxwGRPnnap10jC56bzwr2JxdN3uIVV8FdFMzjLi5+rlYjXTd0/MsSebDX5K7g6refOqqHoUzzNlq4GvKt3V2fYwXGA5OC58G9JlfkxUBH0WB0X+5CWOXLrMH2oRfBnxJt5aKG475KqgfgrmIAallDei6S4heKmhoLFLkldxUgf9lgfXxYMC8uR3xOPixxTo56/npowbdJ1avteyw174sytzy9r+H7Tlp6T9Fyn+xRzlXMuiroWM6XCXVqa1fTyUDbF0oMBocWdGoyL4aS0IIBj1VQ4Krp9MTvyJssHHeQx6vJ5LylPCgy2ZzsecvdVUOfW9VZgT5pzLecXnT1LLt4YfOsxHmwaCNdJQIdXa86XuXLskd5Mu1opc2i7ryI58W+m6zM696YI35ekfnQ0wbO1TCPK3Kx82Ebt6wXrI+TDs5P52TLDi34FlS9UjnU5x8dl5jU19EIlTppWjjJyn5+1eBbl897K/PwVfol7yHfDJ/g+B/OBxSILHJuPm8zKBCebVKgv37cYh6HwftFmyuuCgYh95rcxcDJVd2fW1Mfv8tVX3Zab8DzjjeRKNJ2tzaZ3XNi+6ijdrf1fIl5ct1E+1CDRtrKuCK07MWPL6u/mjrOJP9xRk08HuRFwTKYtVwf5wXOz7bmAQvnZPsOMfi295XKGI0eclDjvEiQKw7aqg7cym5WMG342O83nP71PJx1UcBxQOW2tgEqcUWd4ZuO/ZkWJTwawLlZ5OH2s45ugysysTlvKy1trHjb0N8+KTChmez57LfnDX3uvnXxvMA49PlI24pFlzt2Fsz7ZdJB4G1tYps3/uxiReyqfegiX4q0kdOWA5JXDc8Tyu4g+qqpgH383LyVuMc1P5e9yHOmrzoK5D9M8p8neuacbP2cbM0hBt+CB3sOvpuaJMxjZxkGTFfxvxcNfVfRDrdqp1B25dj9hst82nD6s647rNue8zZcyk55H6LzAaSxyMPtL7pIWBw450202ghwztrcbXLPyeaDPfJ3keSvJmozgPyoQDksRtpWdB1ULNJmP+zBs/byJvdf2t2WJ7YvuwjMZ9rIInXnbCx1OQb2iuZ3G5uzXBX4m2mN3/eowDE/6ag+hvb5VcX011ImXS0UKThuabtvbU0fgm+z2AhlXy+TZp+ZdbbHks4w+K5zGegiDtZ/iLs1hStlz+IuI6dxe957Sf6OW2UVXXFR9blvZTddmDZcz8o+961Ket53cSIVXJ1Rh2U8P2dJc0HigxLr5rTlslvK+U7zpo+r3+axz1nvk5vsj48HsAow73EVr7oMeMSr94ucPG56YtlpYCROIvLq6b558KoP53L8jpM+l0ODFl3ebhrPn7wxZGeT2Q0T2yL14LzFZL3qOE9eFhivtrWBynVL/cXrEulZNpz/4XjzLs7cr+lcLTIXetJxkDxvbn/SQnC86z77qsA52fex4V66Cr6tOoYfMkGn7OtJ3Knmbvy7Jk6QackTuc7oazi+u6Hi7Tr5w1WieDtFmS16iyhyLHV830nB/G1rm++20tPV4KvJgVQ4plWweHXeroLEPyRfr7R2NjAegSav7lzF8lkvux9i2V0k3a7W7NJ1Tt40Xa9/6kEerPrju/FC0JMNffJppq502h93MOk+yZl0t7FqoI6B9IMGv3vRh6BDgcnm8T79e1yxk3d8bVyhz1t5NetJOTTVVncpr63ubCXNljp7iMGmqnXopKVnbb3t2TnTVnryFibUNQ7Iu8iy6Pi5kUV30z47gHPyVU/OyVZ1EXybxUH+s7yoc9xC+1nydQVY3cuV75c8keso/NWzIF6WPUlLbtGbezx5EfVYNlXzfFrz37VV5lWCb4uultY3NPgP5+tqZebGYHGsn9fxWSN1B4oPxXmDbe1FLJ9tZXcV25d7SYe79HbQD4V6/TAnb5qu12cdDyxWD8B+ljcQW9WVhvLifo/rSt4E9boHt5mtJlrLjvrZXrT5BSdU++bD8wLn8qSpYyu4OnrMO5y+7+qLYxudNxF+1ZN2oEydnbS06vhtT/KjyEqwNhYDtDLOin36si/pKfI9NY2H8i409aWdvKp4HINsT/cYO0yTkWk7+HYdJ/GlOqjYgJwm9QbgTmo8kYt6UuWqZIkdQgpN+lpokItuWtDWxKvoCVxlAN1J8KLA6ox9vIzn67zMuRoDOb25Atx38XaWugMwT2LZLUqU3TyucHo58izvU70+7nBgsQq8lepXG7gY1PfB1SACHnFcdZ0z0Z409PXve1ReeX3wj3vm76zAZzf5HMe8z150/My9NtqrvrYBRSbSXbQJIU15Y4AHPTgn28qPedKD29xaXnGUd94s2goaFxxrnLRwvvblYtEip3ymB3BOLgqckyfJyLQZfAuZe1GhgFbbINfVSBSq1AWveBVR164qdd32U6TDrXq1alJnWdSg6PLVKsHAriYhdefh83jL877n68ukoweQdzQpCMcb8ut0x+uqgfq2sY0ou7p2reyeJOMNnj7pYb1+0EE+fOlPKw66i+wwWVgfd7WK/cVJzsRl3qMk5/U/Jw3Wp6HkQZV6lhdobeQh9vEzz/P67DF3sh3fIpXXR1/3eJOLvEDDdORlt2m8tsvfGv7+Wc+Ot+2yabSviAsRds3z5j2rj29zjmfa0DnZp3FL3jnxYzIybQbfKj/cMJ4wbQ8w6qr4z2s6YZZJPVfYpgW+q2onkTvQj4PK456V5xB3Oq1zAn8db/euWldDPR3rKqpNz8kKK6pmO16LFga/L+sI8scg09hWUVxVCUqu1es6+6FpB3lReYOAErtVFTXpYZ3J6wtmPUvvrOLx7FsX+pQP86byIK4syztvzhs4przP7PwZRiOX10a/7XHa8261HOUzlXb4+wD7oSr+0bP0NB30ORnYuTo7sPq4yc85v/fMtz3VuRz+Kqkpcl4wolzHqpSrmiPtr1s8/uuGv6PtiedJTnonFU70eYfP/KhrUhXSX9vKnrjKaJGMSxg83C3ynKyWyy6kpc6gUFMP1+9CrYGiGJyuaxA56WDV18ua8mFWYz70cYCV1z/16XbLIitMRncFecu53mQ9y2tjH9UZzCi44dfrhC7HV7O+JrzFW/2GNH5jvCYDO1fnFY9nDGaHlgdtBd9qGxgUeK5J251uEbVG2mtcLlrk2N43/B37Bjev9nzf/QbLu5NGvebVg008NHhMt8PM4kq3Ni8AFM7nOsuu4G5MQ9HEtvJDXfVV9wYBdfXvQ5wALgY2kD2EFS6NTq4LPEcr5PHjGr/ycU659WW33VEqsDvusse3nBYdmx5S8G0pL0Ytb47Xq+BrHIvtqpN/U6TjC74d9aThLysEhM5bSvu0h8e/GvRXrZB/ayHtPzaQv7MKdSDv+04q1suhN0y1D+LDZCUdwD4dQQO6eu5knWpb9dbQbUehPjwa+KS9kQs2YdVXWq8XNdXradJe8L7udmqWjFfeQP5dWgcMjXs2mWmhTMIFpcsdvw875D6r6bvydtvt4y6bY5LX9w1hJdU8Z+x7rJjlxYH4ZWB99kSRjU8rK98aeB5IK51djbcChZP9tzpfNZ2QJwXKrsjuQHt9R7ydYp/jeF+lDuSsNrpfoZ539YysaU2fc93gIH4Mzw9rYvXUcZ/zt4OVxo3UvQHU67+0PBGrs464jWc4rOqop85fJbtXK4Rbyc9rGIOeFxgjWfXWrLw+ejGAY8h77tdfFDP6OGjH7SEmusXB/kQV+WLWUEM43Tc9sQ7sO6GeNtBwz0ZQzu8H+tltaCoI9aOyG3S9ruuRAm0OGJvoPxcJYwgkUFzeLflPa/iOvM+4suqt88n8zwM4hkXFYwR9HNSkjeDbTDb31qSNyeuOlWZ7rTLLrKTct27d35LOSYWGu8sddOp6JsBcO7A9/Q1Nco4HUHaLgZddY3nTs10ei6Z5qY4cLIGa+rxM8le/nVUcN+WN0Z4rBrTPAMNxWxbsNHF8X1Rd8bPtqtp0j8/KTnb3DQpOS6azbLoGWU+bDCSM4Or83/ucuCYf+DzEANNa+t0WCd33U6NScEOaRxW+osiqt4WSABgtbfwICb7tNpEFvw8yq0xgt91at0+w630dE4ktO1jtG3xbmuCPvhMxaUXdYMhCP26lVL3ynrc23WdH6zg+yXvfa9mPuQzosxmWI1lAiQnmvsGpkw2Dy2mFdHwRAl7p54TGaZ9b98L3rwfM9t1s4Vr1KGRhENgIgV/orl8cStv73EqpesWdVa+S3TuvP9qjnuStmJsNfUXywMYtuwxhs4JJxWOEodg1J6y6kKTtcf1zz/QcJ8E3jVRR4Zlmj/f8nk1Bu+meg93ZhsnPPs9VCYG2lwXSWcR7VamWAWDfO8K+8rDkbnnA74FK+6NTuXDwwsqE8x2/PwvPky0a+IzPnj0v8J20I6/cxtD//qyYGYn5jvnlUp9NH7jttFqnO4ZGqugkY1blizasdNtnldmmNNTy3LeKmy3MxlAZ0jxoOogwGfAk29Unxjz5YrP3OW2msj9wMah2lfNnZXY+zVv1NrfqrVeGMK65r5jAnTf0g+DbbgtZ8I0qt1euT1KmNU2E9h2EHq9NnPZtlBc9uJWnrlVZjU0kWwjsHbQYPG7qs6cDzxv1mn3lBd0N5gnyVqKdF2mjY3tynvNnr2R3ewoEOidN9r8tje1mSpqRyLtgNpVFdD4vkQWt6GvHVjZoExq1sz2/68caJsOzDQOj8Ny3fY9/msmDfRvkPjzv7R81DtCaqqs6vM0WNebvVUNpHHqA4SRp7rZh9Xrc8urN/cQzPw9euACXjkNmOe3Befp6lvNR4dEeuwL64WLflRzvpB046aj/rTbJ+zrePi5wfHAIY+om5zlQrF2WBc13SCO6x7xKg3VSdcK64wrkbM/P/HHLf5fRh+e91XVL5Kbn4CU1fjbf+7nG/G1q8P9g4HncZN7UVa89N3KYY4BwMeqJbCL5uvpt1zjk0dGdOy9zHmHwqMB30E07cJLTR171NO0/5fx+4bEaHFCf/VOD8xwoxG2nO9TVIQ1gSXrR/AiN2mLPt59UnLDOGpi4Trekr6509aWzKeqswbp6lrBx4Ftj2dV+C2T8zKGX3VmDt4ee1/Q5Jj/9HQPsal8nbmMh1pVZznggtEGPd7S158nuFUqhLlpl2Y28MeZZjx9BkNd/zxQvI2qH5znjqZOxzMkZLsG3fHV0TFP58c299vvkx/sG0vTlWR1x0LRPYzzryRXDOm8ZOK87cXFSobPbbFHT5+yc2FXweAR53EgAscBkuatzmHq9zfn9T7KI6HmFupK3KcMrK5Q6UyTo2bu+Mu2jzgqMvd4qXg7sfD2XReTFB5r8cMG3diZFD0aUH1VujzqpsKvobNsvKu78NU32X/XWi1vF4oB8UdPHParzqlAMbD5NaKLubiq745rL7tFIsvpFA3lTZ70WfBvwQN6VdDLt+a6+eBKD9uvtSV6QJPTxbpXqdoyV1w486uHqt7z+e5kem9WUjM3bAZ6r9EujYzrPfMsXAixVr2h9uZ2vjl0xa7zFZd9dOkNHfbnnd/6Y7Hl7VYEgRfj9Pnlzv8JJ1qdBy7ymxuI4lm9dzyl8mlj1ljRUd7eV3cOa0nWZ1Leyq2t1582LGuv13IqWXk+8w6Y+ec98elFj3WLYnueMkUKfeLU+Gcz5zCttRC8m9Gc5fUwo2148AzIGefPGFQJvjLHPvk7r/3LH+HV1p8gzuXWwFjm//7HJL7fyrdjEuK7JWtXONHSk72p6ne/ZqOU9A2eXMHm531AZvK+Qpn1OsmV8tkCfBoZ1maZ17bKG+nqejOO2xabVuYLyrKaye5aM7zl9Z/G4qubN46Te2xZmToHee1Wgbk1lE3E30l0D+0lc6ZYd100r1j/aKde8AOjjuLtop+KqniJzDvWKQ+2zn/bhXKUzeZvdNTqeE3zL73Dresjt2abbDRroTIuqckz7ThZPkvqf91ZHmk5azIOm1J2ecCvV5b5Ls2OA4lIL0vi5uLXsKrQ1oZ0Z663CT+PxVcmbFzWnyU6n45h4v3ErC1Hes9+yK93ynhl4VcddE7Qyoe9LO1Bk1fqsZxeQoU5XRc4TffbBypszH1eJ2eQRfCumrlVFl9krniWFCV9dUfpFxU63Sn5MGjhJqj47a9JhnahrchgG53UPpELD867Mio64gcW7pP4AxZgn9lV2Ed5admk5fChZdmHF44dk/KsVH++RNyexXtedN565Mxx5AZXj2F4azGvTw8RvV7B2GtvbSZK/iva5HO2NlwX66lCmb7pKYIlV608UJyNugxcF2s4wp7ZI4DDrR5GYQWPPvBZ8q2cgVcabMrc+xWDGh6Te25xet1Bp2z5JgjbTNethVW3iFoKTOKEMr40PFg+TzRBUTl9hwPkxGdfuvm153ULZHW8pu/MYWHqX1Bfg77uyefOhoXp9peoPZhxQZOK9qledBOAyAR363x+HgX3eCuOZVW+9agOWSbFgaC2P7tjj/D9Piq1av7LqjQPwssDc/ayLc3Wtz3bBrht5F75P4l1ctRN86yawEW59+hiCcNvuOY8n5GUMZtQ5Ia5r16y2VmvMSvxtW4OJRU8HxNdJfUHi7waTydcrRKHe/haDFuH1S/pv4RUCb2eaib1dNfjZq7L7JZRXpux+i2V3mRxuwLTrvPHMnWG5KPA3rQfg4lgi1Nd3sY1+53k2vZ/4nRXoM61665l4Mb7IuHS1+vy4pTbgRVJsFU+ok1a9cQjn6rJgn13pMTt7nKvH8ft+i332auwpCNeuInewvWhiLCX4Vt9AqqxJ8vUK1YcYzPgQT76PmRPyvInJXk27ZrX1nKL3PUzTrI8VNJZrW5P5aXzpLOopu0XSziqo40zZ0W3eXFvVMrjzdJYUu3h1Evv2RutSZmX807W2OHyvZ9D1vz/eVT6ztu8yoLCHBecDjbcDcSJf5pEID+2cywG1w2FRQpHFImG+3fhFq/j5m+b3X/psJdZq3QhzriJj8Hd1t+GCb+UGUk1ehVxtRjBp8DvqWvX2ZWDYUtbPepimtz2uqnUHiWmPVQ7Km/6PBcKqkSKrrCdx0Pai7iBYnHA/S77eDn2y4/utRh5uf/xa9vV6PvCw4J+v2oHLBtqBEHAr86iP5wK6HKCw+m1RcB7+Ia4k76LPnto1vZfj8NXzfGurF4Jv5Trcl0l7tzY2UsnquuLV0EPiN33PrMTfLlsqn1mP62ibq9+ot+wWSX3BcfrNM3eG7bRE//dlghwHbpOKA/hJHMCHCff6ardtE3+67Y/3eUTHIl6Vp79lO0uK3dK2ch7bgRdV2oHMs0hDG/AiKX73Qehznik5DrQdLrpaNUn+uCutcrAlbtb1ItNn5/G4iHbrxlWJuMHTTBt+VqVuCL6Vd5EMc2XRdQwe1mnWcJpnPUzTvO9L9uMAy8R+mJ4nVi6OnWfuHN5g/jgzcAu3gz4uentLfP7rs3h7adGg28pCafWiTW/jPXQzcSsTgAvn7SoYv5rcTwtO4M/jplarZ5FOSnxvCLxdKDEO+FwNc6LTEn32JPa1v8Q++7xkn/0i9tkf4jlftM+eKa3WlYnrrNrwN7Fu/Lbh9SbvAsuRPC9/AqeZ+iQZ1vbEi5IDhKLCM9bOG0z3+z3f87jBNL0dUGPywRk7vEl92r6ESf07uTHejt4zd0YzFjiNg7AyE+HfH7Sfvj/8mG8Z+IVBXpWr4HOrp3pRTxZpOV+VGCtZ9Tas8r2K53HZOcFJfD2N799058Ykqb56VeANvu2z3yXlnlddtM+uer7O3BHRWb2oM64T6koIwN7dNta38m3PzjYZzu1hX67QNzTZa3rH01lL7+nT59fWmCTNBFxpvuxmidtPx+plfAAwIxm0pT/uJdVWGq+e97r+qhJ4C23IqRLqjTIr2TzrbZhzgjIrYTc53tAGTKrWO4E3+K7PPm2oz65yvq7aELprw+tccR7a8/NtvxR827+gniTt7E5YRRgInDYVSW/6GWv7PBi24TQth/Sw2tiY9KWOzhLLqYfavgy93PqS/lksV8Z1roZ+4V7Sj1sFv9zSnKbn1OrKXtWRRVLsYmWdm2LRbhmH8q0aiK977P9MycB35+oqAHfVk3M1LJBxR0T39SK0l3VerHiw7ReCb9UK6qLHA6VGA28tTGyrfO58YMfadB3tuoMJEw9XdPYru7myq+xhD/Jx7hw4iIHbaYd1LbTz9xp4tiv1KLIR0qsBTcBMFL9vAxYxEP+kw/wJ5/9du5rCznN1GcfYZTZPaqLPvtvA3RBDa5uXPaoXV0n1Vcy5BN+qF1ToZPu2CcM8DsLbmAS87eHnvm8oTe8HWke7DMA1edvzIbQv95Rd9UFWG53pDmFgZSXSYZyvs3jOXrQ4oL+K9esirrBqwmJgA/3epTcGQ2YFyrIvdqV12cD4crHn7/rYDnwJgCXtXpy/jhP5Jy33NfMK9air83CZk49NnTdd1OVFxfJrYlzZtz47nKttbnZ2Fc/VRla7xbZ52aMyH1R6YzD0bg1twdaYgeBbPQX1ZfDbkwodnil0r8FB+KaOrO2BX5PvHcwgomQ5XSTtPwNunrSz+nLs7ctF0v4tbaMqu9ge3u2gjQ7tseDzAY4J4oD+oqF+YxHbhNUAvum+adft0q96WARP9vxdp+lqa9xW0POWy/z1nr/raxuwjBfnf4h52UTZLjMT+Ydd1J/Yt70cWPvwqsH05gUS2q7L1znpaXsTuV3H39mjfcLK9fT1Q+yzmxgnLmL7/0PDF8qK1OPnAzsnn3dQH0JdDBft9709eWe7KPhWX0HNM8996WKiNYuT5S4GlrUvma0y6Y+NWt0N22LogYgYJG7rmSSr1T4CbzUNDJL2lsePsuziJOE0aWc1wqLD9pgetbnh+WvJ18DvkwITobxJXRhfhItrd+NkYdHScVwn36/wD//9vI/PldqR3idd7iSaedbQYkO6XvYsD8OY8uGGtDZS5vEznw+ljpWcxD2Lwfh7sf+p0rcu4mQwBNvamsjnHeOTLWV30ccNhrbUtUXM01lN44xN7fzLtoNLOem56CA911uCKat09qHPvpfps6vkzyx+xqrPftnWhdgd7ekQz8nrDtM1iwsgVoHZ6wLzsOtY5lvL+taudx/duRMy42nFtM/i4LNWadp+q+FjTptoeNK0hV0uHqevR0m57Yz3HZC/6nJAmR5vONYXdU7+Y8S5SprClsHnNaZpVNu1xzJ72kD9XMSJxPWG7wzbe08rfn6pgXj6neH73tXQAN/qSbk12bbsKrs62tuyZVdH/7Ox7GK9CG3EpOY8DJ3tqzjIXtZc9r2ty12c2wNvfyex7q3y7C/Jt7ubhn79H/GcXPTp+U0x7cdDCc73Nb1Dyse205p+30lsq+YjbwemsR1Y9UM/rvXr7zP9SsiLed9XUceyW/ZsFWfr6Y1jtWls15dxXrPo8DhDes5iXetDeiYxPcexn7vuc92O9WSS6af/tjZ+fJ8ZR/etzx5UezqUNiSeUydr4+tC5X6UULvYgIRJxLO0cM6TrztenNU8wQsT5Nc9OcHrTsP7mj7jvGdp6lMdfZnWzatYL5/WEIRYxMnzlRag+bYlLbtw9TwE4X6qoew6D+B3kI+hzbob2+dH6x3onvU/3E7x0i2mFKh/i1hnZgNNu/QeUD62ndZDWTE/xk0RhlZ2TaU3jgOuk/rvDKqSnqse5XtoU14OrJ7M+1KezsnenFN7teF5wbc6OoamOu3nPU5btnBCY3eVuQpyP070piU+ZnXVKwSAZn3rsMOJkh5fnfdk19G4zZJ67xMfXINbojO+ilcazmL9nJbI41Anr3vcWC6Sfj7foI6ye5Z8DcSFsvupZLtStuye13RO9i0fV/V/Euv/g5J5GPLudUv1v891+XVS/QLF6CaiAACwcksWdGfTksUNk0MTErqom5Nk+4qqxT5XwtPP/JhUX6V1MLemVSi70KYc11l2HR1HKOdGbjutWP+XnmUIAACUmmPIgu5UWbIIDdfNRVL/ytCJnG2l7ASG+ln/AQCAA2W3U6BxcZUnAAAAHBzBN6ANJzV9zkxWAgAAMCSCb0AbHsgCAAAADpFnvsFYTuZ6HlAfdr982EDyzur4EBuQAAAAMDRWvgFZZ3U/ny39vGlSz2YLC8UDAADA0Ai+wXjMavqcy5rTddmz4wMAAIDWCL7BeMxr+pyw+u28jg9KPycE3iY1peu9IgYAAGBoBN9gJD7d3CyT+gJwl0d37jyu8gEx8HZe4yFeK2UAAACGRvANxuV1jZ/14ujOnXfxmW2Fhb9PXx+SmgNvMbgIAAAAg2K3UxiXsDrsRY2fNw2vozt3woq6t8nX564tPt3cLH5vRL5u0HASXz/Fn3V7q2gBAAAYoluyAMYlrFZLvgbNxmL56ebmByV7cPX4WfrjadXPSeuOfg5gmP3AJPn63Ni51e975d800xfO5AhAx+2yLIDReZ6MK/j2SpHS0cQlrOIsspI0TArDhiDX2VWhALEtCSvEw3NQw88naTsxlytb82qSfL3wchbza/XvoW19nubdlVzamnchz36KY8Djtd+t+qpwh8TbNB89RxdtsjaZllkRAOPsVMay+i0MFO+64n2QdfhZ0vHKtz3T8DJOENVZYNWWhP74Xfzf0D48kysb8+kk5tPxjj8Lk+RTbew3+RaCbuFC0aTE2xbp68KKOLTJh9Umx8BjOPaTOM86FXxsjw0XYJwuxnIcBtgMTNgl+F0c3ABQbEI4Sb4NvC3S15P09TD5elFjNRYIE8ZLOfZ1Ep2+3qT/GV6TtV+HyfQs81qfXE9iXyUvod3z9iSct+Hc62iseJb88Xzu8P2PlEp7BN9ghOKtb08GfhjXbougR8KV0Vvrr/Tf7yZfg92zzN+uVm8AUMyj5I/A21XavoZV7y/DOCB9PYlt7WI1eYyr5A55Ar9avXKW+ecQoAyPHgl5dy99nWZe99J//yH2V4vMe87Tz3qs+kFrzuLrPGlmk7o8FjV0SPANRioMWsMAdqDJXybjWb3HuM+zsPtvmCieJt8GvMOVzXM5BFDINNP/P9nQ1q4CS9kJ7EFau21sJYz5QtDt2bZnj4Y8jP3V3fj3KwvVDw5m3HqdmR/OkuEv1hgUwTcYt9CgDu0+/tXzB1yZYWgDmpdrk8OncgWgkFUgadfOplbDf3WZfBt4C4/oeFJm3BRXE4bVcPfcZQAHN169iHdwmG+1TPANxt24fglkJcMJwHnwJ0OXfTbR5NBvjQIoaLFqN3f8zeTQMylurpBd9Xex7w6wYaxlvAXQHsE3GLlMAK7vVzYF3hjL+XZtsghQyqrvn8SdCDfJBp0WB5pPLzL/fbVv4A2A9h3JAjiYgMDD+FDdFz0ddF8IvDESP2f+O6x8ay3wHVfahQnq/Q3n2Nv0HJt1NuD4upvh+Ya0hUn0++TrJivLDtMX8u1B8n3A9G1MW6eT/b7mX6xz4Rbrv4fnTcV/O45pfbCel/H27LbS9VPy/QOtw7nwug/9TQwy/ZRs3qmy0/O1A6+SP4JrYRfAe9n6HOvUale+ZXKAt6DGNmqSyYMnAz2O40w/tV73Q1t21VV7m6YttGF/C3m7qn99P0/71Ddk+oPXZW9nzrz3fVv9xKGqUk4V269wHj1f9b87+ulFPLeue5Jfk0ybld2hdpk5xxZqFrCxwU1fYXv533ryetHRVtv0u54+q6N+1ZiGZyXe9yLzvvO2BgYFz+sPbd8KG87v9HVZIG2/dLHrXhgQpq+PBdJ32UVbVaJsfylTT2tMXzZtXzYaiWnZls5pT/q4d22dC+GYs21JH9PYk3b/3VpbdZxpQz7s0x6PLH/eDDkPYjk+y2kfsnV/0nL6BnWe9rFvzeZX1b6kzbJuuW3LK6uzPpdThXFM9nw5XmvPtr0+Nj1mqOkc+y0eT26b5bZTODDxGR/hNtT17ebbNku+3mb6xMM+GZlWb42Kg9QPyR+7BWa/e311z5e/bXkn1rAr3/mGtM3W/i1MtEPg8rLFgVVYCfwm2byiYb3swjG8azMAF8tpU9luEtL1NBu06EC4kn6ZfHtlOGvZ5DlRMr+msTzbnjQ/iOdEn9PYlYeZNuskHvsk+XZnz6vVCssDlK0zV0NKeKYcn+5oH9aP9UMbgYgBn6e97VtrcDziczfvuMfY3k/W/vtjUmzH6kk8t87bTnA8nz9uOMd2jf1zL3ALvsGBymw3Hwa7bS7rDYOC07jDzkxJMCbrtwU1XcdjJ/8uM1ANA+8QWP8hnN/pK9y6dWttUhtctjFRiFfbs9/zPJO205i207XJwnlLV35D2h5vaJtuxXwL7eMPMc3LbECgpboUBuvZQNYypuVuTOOtTNlm2/BV0KKLycvZhnp4K/P6oalbMzL5lWxLQyzP7IWn4w4mzSeZMg0BlIdr5Rl2oHy5NhlrfRVQR+OS9U2iVpOfbODt4kD7lmy9WQzpFqfYFr1Z6wtC3b+3VvfvrrW3X97X0cqXIufpVVfnaQxG7NO3nid04Uksi1ny7QWoeebfZ7FOXY08LyaZc2sWxzA/7GgHVmPW1tqBDWPrJPbLRdqsdzZbA4o0NGFJ8OOCy4DLvj7Ez57IaQrWx8HddhpvUcneTnPZQj5tvE1rx99nl89/aDl9j0uk7byF9u63EmlbL9tnDafveO37ipTt+fot/S2dq+u301x20F4cr906vPMW4Q23vDRdntOytxZ10Z70KViz4dbEgzn+AnXo3cDS/mat7k8LlP+Htfcct5zHvT5Pe9y31nXb6bTFsn7W8vnwrK3jbKKcajq3itTb9XbgY4v5s97+nBRoBz6s3S67sc2y8g34IlxFDQ84TV8PM1fMwpWaEOmfJd/fvrZN+NuwCiNcCVhdzbgXP3shpxnhpGgSB9whmJVdpfSk4e8Ng7Zp5vtO827hjqtGfl9V0uYtPXkPUI5puxeP46rh5DzN/PdVgbTNY5u48qjh9L3I1KV5wbINeZZdFdTFBY9FRyuTwiB+ksmvnY8zCL8LfV3s366Sb1eateF53oOkY517mPmn80O4gBUnLNn6n2TaK8+H/er9gMoz9FHZfib3rofMCsjVmPE4+XaVsvO0v30rFPGyQL1dxnNr1ZdPWror4jz5Y1Xpamw9LzhG/D2t29oswTdgW0MyiwGzJ3EJ+72124e2vU5jAO9ZGLR4nhsj8VO8Urj+ClcN158JUSgQVoNsAKjMsxOfZ/77QYuTsPMC7c68pdvRzzNlVShIGgdXq4nLcVODwMxOgKXLNk6srrfUkVYmq12dn3vmV/jbi5b7qUXRnfziuZA9H6ZjbmRj3c8+x2qefP8MOAG4JPnLkPrOtQn3vGDdD+fkRYdtWdnzdN7VedqzvhVqGyvERRtXmX+630Lasm3N85Jt1pMtbd/vBN8AIN8kDqjXX+vC4Pa0aGdd0TTT6V8VfdPalfymJwlvM//9It5+3unkee02j7IXCLLHc9Jguf6+6m2PCVN2UNv2w8oXHZTnJPlj1dtiABPMsul7v9YOjVIm8Pb7892SrysJ1p8B9y7nluJpMn5Dep5Qtg16VeaN8VxetSnHLZdt2fP0bcvn6eu+9a1Q0LyH465sP7T+bMoybVb4++xKve/agiPlDwC1eFL0SnlNfn/49h7PLFnECUKjk4SQH2nafkr+eHj1izhRmMWgwjwOxBYt5lt2AjcpmXd/y/z3jy1MrN/ukefz9JiWMb8nB3DeZY9xPoD0/rxHEOBpw3WuD9Z3NL3ITIhOM79fBeC+WV2cDd6l/z3GjRkWW+p8b8WJZ/ZCwj7tfLhY9DjTNs6cp18n+bFvnfaob4Uiyq40b7MOZ8dfsz1XxYdz8CzTVn+TfsE3AMgXlp4/2zC5eJf8EcwJA+FWgm9rKwAmybfPMOuVcMt6fPh/9vkX00y+heMJg5NwJf9ly7cAfpOOktpYZbDvRHO+Oq7wIOCWVmL2wd9HfnyjXNkS24eTzITnYq0NWRYIwF1mPmN0+RSCKNmgeghsDSCwMqkw4V75xwDr/3FLdeK0x30r1Nn2dfHV+z5bM4xDzjLn4zfjOLedAsD+ss93OMnbvamHWgnKhGdrJV+3ZH+SbA4ohUlaCCB+HNAW7UN56LlbkeituDpq1W6uHrC9qQ1ZPYT/u1tQ44Y3Z5k27WKk2dXl8xzpoZH2rTBagm8AsP/AN0z0ss/YetrSTmfZoNms4GYom173Wsyr1Y7Kp3FH5XtxknyV+bPjOKFua5JwUSHvnrWQvume7zvUSdbftEqDk30m2FXeLrXJ9wG47IY3y3hOj3WFT/Y5X+cDeMbXYq1tp52+9W4P+tZEsI+B23dzh523nQu+AUA1LzOTjNWzV5oebC+TP27jGeQAN+6+tno2093MhDrkYZOrOmY1DK6aNC86iNsx4TmkiW52gj/VHA1Oto6/LdBurAfgVnV9tcv0aG+xXtv9Nhz3Zc/Tu8j2U3sGCx9sabvZke87+tY2H1Eh4CqPhibbf+w7tt75PsE3AKg20P2y2iLzT2fpJKONXSZXtyCF267Ohz5ZSL693eyswe+arZVV3wa/6+mblHz/owM7/0LdWcT/nRzIbpdjMtmjzJfJ94GYbD0Ys+dr7UPf2/5sOZV6LEM8l1cT2eUAdjIeQt/adPuYDV48KFHWx8lhXjyxOrB/4/n5vmPr+Pc7+zTBNwCo3mGHScFV5p9etBDUed3y95UWVmEVvfVk7eHhTR/LVeZ7LntWl5ZrdemyRH6Hycv5AZ6Cr7L5NYDb8fhD6fM+TnAeb5jEvht72ce+5uVafd/rnA/va+E5pdlz82nR/iCWY3YV+bVTZRB9a/ZZqGVuje7yeblt7yK97PC7aWhsHf8ud2Wp4BsA1ONJZlA1SRq+vWPDLUiFJp5hshUeUN70JDWu/vsQXkUmh2srlpq+dex5pqzO4gPb89IXVlW9aGlTjezqlmmR8or59+ZAz72rJLP6rci5ECevb9LXM01Xp7KT9acFzsNwrmbP14tkwyYMY86w+JD9bBt5Gety0UliaMvexHxstE1b66eSpMBzx+JxvEkyq97W2sSDtta3Pi7w9631rWl5XyffPoajSFt8nrS/Y/tyrY9ts83IBpLPhn7nwsjHE0Xr8Je/Swqs5BZ8A4B6Bp1hMJfd/fRxCw8cvki+ffZb2NHs2aaBQlzlEB5OHlYThMFe00Gkk7XJ4btNt+PG3QofJ98Gjt42XFaLtbIKefNhS/omMUDzIebZi6bLNaYveyvzeZxofbeSIKbvMg78jjdMLA7l3Hu4Vvd25dezmF+hvJ96MHinrpNvnwv2ZtOt1iGAEM7R5NuVnWFzhTBR2rgL6sjz7XQtkHIW2/+t7VMMOF/GtuysxbRm+6njeG4+Wy/n2Becx/RNM796srZ669Bl8+1Fn/rWVXkVbItPMkHgtvuM+VqA5TK2MdMWvjt872xtfPRi9f0tbdrF7vHExVod3ji2zrRZHzNj3tmuz78liwHomzg5rnwlNO78VUcanhfd3TIMhDMTh7AT6WnDeXWSfBt4WZlnJjzrA8ovwYomn6GTuRK4aSI4ywx6138/b2sX1jhoutyRvkny/ZXMkK+nbeyouCN9q7LdlL4waPwpU+anDZfzu7a+q0BazmJ+HZfIr8brW5zQvSvblmx4b+PtSUfltqmez+LkeNVGTNbar282V9jQ3lynv394AH1luJiy6UJK9tlFm/qAldWD+ZtO57Z+arFWzutWAdY28nIQ5+nA+9ZlLO+TDf++zJznjfclsb/YtFr8ZVxd2uR3h+P8kGy/DfhukwHnbL9dZZzc1vmRvv+3tvvAHXV4V5t1kXx758t37YiVbwCQr8wg6KLAhKc2cQIadjRbn6CcxO+fbhicNz6wDcGpONDP3uKZzZfphoFLeJZRa8GFzKqZxZb0rU/4nyctBd5y0neyIX2LmLarCnV30OItT6fJ91eeN+VX6/WtBsuRlttV8u3qqNU5GCY/Z2vlNosT0/l6e5N8vxrsEOr8ky11/jjTjk239GkP2wi85fRTky19QTiee20F3oZ0ng6ob324IX3HW8p6vZ9btpDG6w31MUla2AQhBtZ2tVeTAx5D96lfurehjDa1Wav2NLznb5l//658rXwDoHfiFaefaug8TyukIXSwL+Ig8EmZgEsm/e/LXD2vId8mccJ6P/ljlc9qBUR4ttJVF7fvxCv1Z5l0ncRB+CK+OktbJo0hfQ/W0re6NSXcqnPdVtBtR526nxn4rSYtX9IXJxLZY3nURv2LV7TDVd5506sF9kjXg1iW6/VtVZ6LFuv/i5iG5+uBowLvv9z3vQNr949j+/Ug+TZgtIh1/XXeRYP4GSeHuDNmXF3205bgy2oiOF9vLzpI565+apW+WUf1b1Dnad/71kz6Vm3xZK0u/n5OZ/qStsdN03jerNL2pM12dm3s8aW9azoo3uYYIfOdz2I9fVW2/any3gbqyDRTh1fjr6vM337MlOW9MffZAAAAANCa+My+3+Lrl01/47ZTAAAAAA5a3ADj3R6bMWWfVX0tJwEAAAAgI+7C+/vqtaIBuHDbeeZ9v9m1FgAAAAA2OLpz58NaAO5ZfH7hpr89Tl9v1gJvj7d9tg0XAAAAADhoMdD2Lvl245qwKcwsff09828/Jl83FMm6amsXaQAAAAAYpLii7cXaira81+O8z/2TrAUAAADg0P36+fM/09d/vX109D7+0yR9/XnDn4YVcf93+nr46ebm/8n7XLedAgAAAMAGcfOF7LPflp9ubuZyBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGLX/X4ABADdvGiZHZ1RtAAAAAElFTkSuQmCC" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-21</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML and GPX file of all sites is attached to the application and can also be downloaded <a href="https://github.com/lucy-schick/fish_passage_peace_2025_permit/tree/main/mapping">at this link</a>. The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program and the Provincial Fish Passage Technical Working Group. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are provided below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br>
<br>
<br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<!-- ![signature](/Users/airvine/Library/CloudStorage/OneDrive-Personal/Admin/Al_Sig.jpg){width=50%} -->
<p>Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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+byZx4cRgYjABYlAZJAuyG6LlY4I/OgROH36tMnL3ete9zoTMSoVqiTIG5nc5urZxz/+cXfSoEMXP/vZz5rUXi677LIkavyOCMyJwEJjTOcllZ+ZpIzuueceu+222+yNb3zjnPnGBxGBcgQ+9rGP+SHXOq7ghRdemHgkabeYroWeTySIFxGBiMCyQSAySMumK2NDIgI/XAT+4z/+w2QDUq7elNRA9khvfvOb7Td/8zftT/7kT9y7WFVVla1fv96JDXkciyEisBACixljC+URn0cE5kNAxxHogFgF2bKVBx1LIE+d8z3XOXExRAQiAssPgQrOOBlffs2KLYoIRAR+nBAQI1UsFq2pqenHqVqxLhGBiEBEICIQEYgIRARmIBAZpBmQxBsRgYhARCAiEBGICEQEIgIRgYjASkUgnoO0Uns+tjsiEBGICEQEIgIRgYhARCAiEBGYgUBkkGZAEm9EBCICEYGIQEQgIhARiAhEBCICKxWByCCt1J6P7Y4IRAQiAhGBiEBEICIQEYgIRARmIBAZpBmQxBsRgYhARCAiEBGICEQEIgIRgYjASkUgMkgrtedjuyMCEYGIQEQgIhARiAhEBCICEYEZCEQGaQYk8UZEICIQEYgI/LgjINfxBw8edPfxP+51jfWLCEQEIgIRgQsLgcggXVj9FWsbEYgIRAQiAiCgQ2S3bNli3/ve9yIeEYGIQEQgIhARWFIEIoO0pHDGzCICEYGIQEQgIhARiAhEBCICEYELGYHIIF3IvRfrHhGICEQEIgIRgYhARCAiEBGICCwpAqklzS1mFhGICEQEIgIRgR8hAo899ph97nOfs/3797sK3k/+5E/a61//+ik1+vSnP22NjY1255132j/+4z/a448/bmvXrrV3vetddsstt0yJG39EBCICEYGIwMpDIEqQVl6fxxZHBCICEYFlicAf/uEf2o033mj//u//blVVVfaNb3zD7r77bvvwhz88pb2f+cxn7BOf+IS99rWvtd///d+3EydO2N/93d/Z7bffbl/4whemxI0/IgIRgYhARGDlIRAZpJXX57HFEYGIQERg2SHw0EMP2Uc/+lF7z3veYy+88ILdc889tmfPHvvIRz5in/rUp1yqVN7oBx54wN761rfayZMn3dHDU089Zfl83j72sY+VR4vXEYGIQEQgIrACEYgM0grs9NjkiEBEICKw3BD4+7//e5caffzjH7d0Ou3Nq6iosD/6oz+y1tZW++QnPzmlydls1iRxElOksHPnTrvqqqvcdfiUiPFHRCAiEBGICKw4BCKDtOK6PDY4IhARiAgsPwR+8IMf2ObNm50ZKm9dLpdzxkdSpfKwceNGy2Qy5bc87cDAwJR78UdEICIQEYgIrDwEIoO08vo8tjgiEBGICCw7BE6fPm11dXWztqumpsaGh4enPCsUClN+64ckTuPj4zPuxxsRgYhARCAisLIQiAzSyurv2NqIQEQgIrAsEdi+ffuc6nEHDhywq6++elm2OzYqIhARiAhEBJYegcggLT2mMceIQEQgIhAR+CEjcOutt5qkSF/+8penlCznC7t377Zrrrlmyv34IyIQEYgIRAQiAnMhEBmkuZCJ9yMCEYGIQETggkHg137t19wG6ed+7ufss5/9rMkm6fOf/7y95S1vsa1bt9qv//qvXzBtiRWNCEQEIgIRgR8tAvGg2B8t/rH0iEBEICIQEVgCBOSN7sEHH7QPfehD9sEPftDGxsasurrabrvtNnfzvWHDhiUoJWYREYgIRAQiAisBgQoMUqNF6kro6djGiEBEICKwQhCQJzrZHe3YsWPC5fcKaXpsZkQgIhARiAgsAQKRQVoCEGMWEYGIQEQgIhARiAhEBCICEYGIwPJAINogLY9+jK2ICEQEIgIRgYhARCAiEBGICEQElgCByCAtAYgxi4hARCAiEBGICEQEIgIRgYhARGB5IBAZpOXRj7EVEYGIQEQgIhARiAhEBCICEYGIwBIgEBmkJQAxZhERiAhEBCICEYGIQEQgIhARiAgsDwQig7Q8+jG2IiIQEYgIRAQiAhGBiEBEICIQEVgCBCKDtAQgxiwiAhGBiEBEICIQEYgIRAQiAhGB5YFAZJCWRz/GVkQEIgIRgYhARCAiEBGICEQEIgJLgEBkkJYAxJhFRCAiEBGICEQEIgIRgYhARCAisDwQiAzS8ujH2IqIQEQgIhARiAhEBCICEYGIQERgCRCIDNISgBiziAhEBCICEYGIQEQgIhARiAhEBJYHAv8/GvZI314x5wgAAAAASUVORK5CYII=" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125825
</td>
<td style="text-align:left;">
Purvis Creek
</td>
<td style="text-align:left;">
237-673200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355055
</td>
<td style="text-align:right;">
6122848
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200337
</td>
<td style="text-align:left;">
Moosmoos Creek
</td>
<td style="text-align:left;">
237-528900-48700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
406967
</td>
<td style="text-align:right;">
6138657
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201576
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-331000-04000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
429809
</td>
<td style="text-align:right;">
6124738
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400370
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-913400-47700-11700-2890-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
453321
</td>
<td style="text-align:right;">
6157621
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400506
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-901300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456059
</td>
<td style="text-align:right;">
6188410
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701130
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-846900-11400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522727
</td>
<td style="text-align:right;">
6199674
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701150
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-860500-56200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
482825
</td>
<td style="text-align:right;">
6240727
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701333
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-846900-18000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522811
</td>
<td style="text-align:right;">
6196513
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701346
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-846900-21000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
523799
</td>
<td style="text-align:right;">
6194962
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701712
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-871000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488844
</td>
<td style="text-align:right;">
6198242
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
16701773
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-828500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
540327
</td>
<td style="text-align:right;">
6221480
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:left;">
230-906800-65600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
198692
</td>
<td style="text-align:left;">
Tributary To Kerry Lake
</td>
<td style="text-align:left;">
230-906800-97600-22400-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511734
</td>
<td style="text-align:right;">
6059315
</td>
<td style="text-align:left;">
CRKD
</td>
</tr>
<tr>
<td style="text-align:left;">
23502802
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-815600-04500-63200-0210-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
530426
</td>
<td style="text-align:right;">
6205816
</td>
<td style="text-align:left;">
UPCE
</td>
</tr>
<tr>
<td style="text-align:left;">
23502870
</td>
<td style="text-align:left;">
Track Creek
</td>
<td style="text-align:left;">
230-815600-09900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
545962
</td>
<td style="text-align:right;">
6203536
</td>
<td style="text-align:left;">
UPCE
</td>
</tr>
<tr>
<td style="text-align:left;">
23502871
</td>
<td style="text-align:left;">
Gaylard Creek
</td>
<td style="text-align:left;">
230-815600-04500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
531258
</td>
<td style="text-align:right;">
6206271
</td>
<td style="text-align:left;">
UPCE
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62622
</td>
<td style="text-align:left;">
Unnamed Tributary To Tributary Of Chuchi Lake
</td>
<td style="text-align:left;">
237-447200-60000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
421633
</td>
<td style="text-align:right;">
6103622
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
7819
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
230-870800-11500-24500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488605
</td>
<td style="text-align:right;">
6187223
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
<tr>
<td style="text-align:left;">
7827
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
230-870800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
506054
</td>
<td style="text-align:right;">
6164113
</td>
<td style="text-align:left;">
PCEA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125825
</td>
<td style="text-align:left;">
Purvis Creek
</td>
<td style="text-align:left;">
BB;BT;CAS;CSU;LKC;LSU;LT;LW;MW;PW;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200337
</td>
<td style="text-align:left;">
Moosmoos Creek
</td>
<td style="text-align:left;">
BB;BT;CCG;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201576
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400370
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400506
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701130
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;LSU;LT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701150
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701333
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701346
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701712
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16701773
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198692
</td>
<td style="text-align:left;">
Tributary To Kerry Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
23502802
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
23502870
</td>
<td style="text-align:left;">
Track Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
23502871
</td>
<td style="text-align:left;">
Gaylard Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62622
</td>
<td style="text-align:left;">
Unnamed Tributary To Tributary Of Chuchi Lake
</td>
<td style="text-align:left;">
CSU;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7819
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7827
</td>
<td style="text-align:left;">
Trib To Clearwater Creek
</td>
<td style="text-align:left;">
BT;DV;LSU;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
<th style="text-align:left;">
Peace Arm
</th>
<th style="text-align:left;">
Upper Peace
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
