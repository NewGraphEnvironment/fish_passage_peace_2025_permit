<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/mapping/sites_peace_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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fIsVFOHGPQsYRzEm34jKXQGe/k7m99tSOP8JgrW2tbTbhXjWiwOg4gROvOEtD9ouQH0Eqnz95mvR4ayxJfUldkd1iR09eMTqAYsrADVS8biy5GoCmgagWABC71i4cond/sBdbhQsQqEAIlkSoHvf/hZ7Ydt2788bbr3eqlBbFJCrWFJjiaoiu+neO7B36rTKJfV2/3veClja7s4PVq5fiYRl0NrSPUghCjAoLkfpRLBQAAmCQg0UJhpDtjByliBgLF5skJwsCu865XuYMdfN+FYfKVDs6ZLqWApIkqF1f+coKne4x0Wi1p7psY0Fq2zz4g2097hJbUUudA93YROAmuBxVFb+7fkO++CV91hnug9X4zwHQ6Ebd+MlNcyvskC600M5hhmXjTArSl0qRvn534eB9fYDh2wUyd+qugZbuQxQgv3X0WNIGDswrC4usva2NluwoNEqcPTx7HNbbceul1FRHbULsevauPEy271jF9669pMd7rp5/zWoca5cudKeffZZexkmg1QJO1BDXbxokY2hHrsTu7kDB/e7W/LLUf8sqyi157Y8bW3YpC1ZtBj1xyHrPNEJqO931dmryW/FmhXEn9mBdHInKq/D1tS0xC698nJf07ZRpn379rE85NujX3nYtmzZcrpmPqfPKyDpF77wBfvUf/7rOQSQgi5zkJSPlz4YOcJI0wvVdJeibAejC5f8zBMlSdNu+sUH7MSug6zfuOKH+aHEVAzWPl/sgDrhvjK1+PltMz40yydYQzX3fccBeEji4mnquUA6I2aQGG2+X01dgz8lFTYhEJL2OUln56qHri956xXWtHGNlbC+t2S6GPNZOz3ykLpnGYyDCIBJzkqUpaLsSeKt12peK42jbgwKcgCkc9xK0vvZWXkodHgzSbuoTaWqJyBVhKOkq5avt8bSCu7UepgtJuv9GEBKruilTr+8phIJ0xCS7cO2pnGZnejuQILVg9e7CmfIXIU303996r+QIpfaBQuW+prr7cizSn6cs8T6yfmP864F5gHSedflP5kKCyCtXr36jC+TTcYf/uEf2vve9z5THIapzeCMT71+F7W8Km7MYKbYAysOFfQ416kUoKQAnSliFWWX36mXKiiihPDFcKeqJ0usYCIF6Ag2vambdKANSganwXo741LuD10OdP6DDWkSNbhb77sD7neBHcMFqYx8FXm+YckC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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
