<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML and GPX file of all sites is attached to the application and can also be downloaded <a href="https:/github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/docs/sites_peace_2025_20250725_kml.zip">at this link</a> (or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a> if this is not the latest version of the memo). The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
