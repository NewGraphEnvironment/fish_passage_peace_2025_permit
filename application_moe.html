<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-25</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML and GPX file of all sites is attached to the application and can also be downloaded <a href="https:/github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/docs/sites_peace_2025_20250725_kml.zip">at this link</a> (or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a> if this is not the latest version of the memo). The KML includes detailed site-specific information accessible by clicking on each location, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
