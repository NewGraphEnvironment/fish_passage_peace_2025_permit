<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https:/github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/mapping/sites_peace_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
